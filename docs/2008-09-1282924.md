# 静态方法和实例方法 
> 原文发表于 2008-09-03, 地址: http://www.cnblogs.com/chenxizhang/archive/2008/09/03/1282924.html 


静态方法：   
静态方法是不属于特定对象的方法，静态方法可以访问静态成员变量，静态方法不可以直接访问实例变量，可以在实例函数调用的情况下，实例变量做为参数传给静态方法。静态方法也不能直接调用实例方法，可以间接调用，首先要创建一个类的实例，然后通过这一特定对象来调用静态方法。

    
实例方法：   
一个实例方法的执行与特定对象关联，他的执行需要一个对象存在。实例方法可以直接访问静态变量和实例变量，实例方法可以直接访问实例方法、和静态方法，静态方法的访问方式为类名加点操作符加变量名。当多个实例对象存在时，内存中并不是存在某个特定的实例方法的拷贝，而是，相同类的所有对象都共享每个实例方法的一个拷贝（实例方法只占用“一套”空间）。 

  

 常见的一些误区 【摘自下面链接】

 [http://www.cnblogs.com/Ivony/archive/2006/06/30/439377.html](http://www.cnblogs.com/Ivony/archive/2006/06/30/439377.html "http://www.cnblogs.com/Ivony/archive/2006/06/30/439377.html")

 一、 静态方法常驻内存，实例方法不是，所以静态方法效率高但占内存。     事实上，方法都是一样的，在加载时机和占用内存上，静态方法和实例方法是一样的，在类型第一次被使用时加载。调用的速度基本上没有差别。 二、 静态方法在堆上分配内存，实例方法在堆栈上。     事实上所有的方法都不可能在堆或者堆栈上分配内存，方法作为代码是被加载到特殊的代码内存区域，这个内存区域是不可写的。 三、 实例方法需要先创建实例才可以调用，比较麻烦，静态方法不用，比较简单。     事实上如果一个方法与他所在类型的实例无关，那么它就应该是静态的，决不会有人把它写成实例方法。所以所有的实例方法都与实例有关，既然与实例有关，那么创建实例就是必然的步骤，没有麻烦简单一说。实际上上你可以把所有的实例方法都写成静态的，将实例作为参数传入即可。     有些方法看似与所在的实例无关，如IComparer.Compare方法，但实际上每一个实现这个接口的类都只会负责自己类型实例的比较，这是C#1.x规范中没有泛型所带来的历史遗留问题。     大部分静态方法是与类的实例有关的，如各种Parse方法，他做成静态的原因是他没有实例作为参数。其他的大多是出于语义或者其他目的的考虑。















