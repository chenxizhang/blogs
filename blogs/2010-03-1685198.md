# 事件处理程序的处理顺序问题 
> 原文发表于 2010-03-13, 地址: http://www.cnblogs.com/chenxizhang/archive/2010/03/13/1685198.html 


<p>这也是今天讨论到的一个话题，其实还是比较简单的。因为事件处理程序都是在主线程被执行的，所以主线程肯定是依次执行他们。那么究竟是什么决定了这个顺序呢？</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;
<span class="kwrd">using</span> System.Reflection;

<span class="kwrd">using</span> System.Threading;
<span class="kwrd">namespace</span> ConsoleApplication1
{
    <span class="kwrd">class</span> Program
    {
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">///这个例子解释了如果为一个事件绑定了多个事件处理程序，那么他们处理的顺序与绑定顺序是一致的</span>

            Console.WriteLine(<span class="str">"主线程号是:{0}"</span>, Thread.CurrentThread.ManagedThreadId);

            Employee e = <span class="kwrd">new</span> Employee();
            e.NameChanged += <span class="kwrd">new</span> EventHandler(e_NameChanged);
            e.NameChanged += <span class="kwrd">new</span> EventHandler(e_NameChanged2);
            e.Name = <span class="str">"ares chen"</span>;

            Console.Read();
        }

        <span class="kwrd">static</span> <span class="kwrd">void</span> e_NameChanged2(<span class="kwrd">object</span> sender, EventArgs e)
        {
            
            Console.WriteLine(<span class="str">"第2个事件处理程序触发的时间是:{0}"</span>, DateTime.Now);
            Console.WriteLine(<span class="str">"当前线程号是:{0}"</span>, Thread.CurrentThread.ManagedThreadId);
        }

        <span class="kwrd">static</span> <span class="kwrd">void</span> e_NameChanged(<span class="kwrd">object</span> sender, EventArgs e)
        {
            Console.WriteLine(<span class="str">"第1个事件处理程序触发的时间是:{0}"</span>, DateTime.Now);
            Console.WriteLine(<span class="str">"当前线程号是:{0}"</span>, Thread.CurrentThread.ManagedThreadId);            
        }
    }


    <span class="kwrd">class</span> Employee
    {
        <span class="kwrd">public</span> <span class="kwrd">event</span> EventHandler NameChanged;

        <span class="kwrd">private</span> <span class="kwrd">string</span> name;
        <span class="kwrd">public</span> <span class="kwrd">string</span> Name
        {
            get
            {
                <span class="kwrd">return</span> name;
            }
            set
            {
                name = <span class="kwrd">value</span>;
                <span class="kwrd">if</span> (NameChanged != <span class="kwrd">null</span>)
                    NameChanged(<span class="kwrd">this</span>, <span class="kwrd">null</span>);
            }
        }
    }
}
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/f79fd1bc11ab_10EC0/image_2.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/f79fd1bc11ab_10EC0/image_thumb.png" width="681" height="446"></a> </p>
<p>其实要深入看的话，这是因为事件的处理程序是通过一个列表来管理的，就是EventHandlerList</p><pre class="csharpcode">
[HostProtection(SecurityAction.LinkDemand, SharedState=<span class="kwrd">true</span>)]
<span class="kwrd">public</span> <span class="kwrd">sealed</span> <span class="kwrd">class</span> EventHandlerList : IDisposable
{
    <span class="rem">// Fields</span>
    <span class="kwrd">private</span> ListEntry head;
    <span class="kwrd">private</span> Component parent;

    <span class="rem">// Methods</span>
    <span class="kwrd">public</span> EventHandlerList()
    {
    }

    <span class="kwrd">internal</span> EventHandlerList(Component parent)
    {
        <span class="kwrd">this</span>.parent = parent;
    }

    <span class="kwrd">public</span> <span class="kwrd">void</span> AddHandler(<span class="kwrd">object</span> key, Delegate <span class="kwrd">value</span>)
    {
        ListEntry entry = <span class="kwrd">this</span>.Find(key);
        <span class="kwrd">if</span> (entry != <span class="kwrd">null</span>)
        {
            entry.handler = <strong><font color="#ff0000" size="4">Delegate.Combine</font></strong>(entry.handler, <span class="kwrd">value</span>);//这里的关键在于Delegate.Combine，所以根据注册顺序不一样，是一个顺序型的组合
        }
        <span class="kwrd">else</span>
        {
            <span class="kwrd">this</span>.head = <span class="kwrd">new</span> ListEntry(key, <span class="kwrd">value</span>, <span class="kwrd">this</span>.head);
        }
    }

    <span class="kwrd">public</span> <span class="kwrd">void</span> AddHandlers(EventHandlerList listToAddFrom)
    {
        <span class="kwrd">for</span> (ListEntry entry = listToAddFrom.head; entry != <span class="kwrd">null</span>; entry = entry.next)
        {
            <span class="kwrd">this</span>.AddHandler(entry.key, entry.handler);
        }
    }

    <span class="kwrd">public</span> <span class="kwrd">void</span> Dispose()
    {
        <span class="kwrd">this</span>.head = <span class="kwrd">null</span>;
    }

    <span class="kwrd">private</span> ListEntry Find(<span class="kwrd">object</span> key)
    {
        ListEntry head = <span class="kwrd">this</span>.head;
        <span class="kwrd">while</span> (head != <span class="kwrd">null</span>)
        {
            <span class="kwrd">if</span> (head.key == key)
            {
                <span class="kwrd">return</span> head;
            }
            head = head.next;
        }
        <span class="kwrd">return</span> head;
    }

    <span class="kwrd">public</span> <span class="kwrd">void</span> RemoveHandler(<span class="kwrd">object</span> key, Delegate <span class="kwrd">value</span>)
    {
        ListEntry entry = <span class="kwrd">this</span>.Find(key);
        <span class="kwrd">if</span> (entry != <span class="kwrd">null</span>)
        {
            entry.handler = Delegate.Remove(entry.handler, <span class="kwrd">value</span>);
        }
    }

    <span class="rem">// Properties</span>
    <span class="kwrd">public</span> Delegate <span class="kwrd">this</span>[<span class="kwrd">object</span> key]
    {
        get
        {
            ListEntry entry = <span class="kwrd">null</span>;
            <span class="kwrd">if</span> ((<span class="kwrd">this</span>.parent == <span class="kwrd">null</span>) || <span class="kwrd">this</span>.parent.CanRaiseEventsInternal)
            {
                entry = <span class="kwrd">this</span>.Find(key);
            }
            <span class="kwrd">if</span> (entry != <span class="kwrd">null</span>)
            {
                <span class="kwrd">return</span> entry.handler;
            }
            <span class="kwrd">return</span> <span class="kwrd">null</span>;
        }
        set
        {
            ListEntry entry = <span class="kwrd">this</span>.Find(key);
            <span class="kwrd">if</span> (entry != <span class="kwrd">null</span>)
            {
                entry.handler = <span class="kwrd">value</span>;
            }
            <span class="kwrd">else</span>
            {
                <span class="kwrd">this</span>.head = <span class="kwrd">new</span> ListEntry(key, <span class="kwrd">value</span>, <span class="kwrd">this</span>.head);
            }
        }
    }

    <span class="rem">// Nested Types</span>
    <span class="kwrd">private</span> <span class="kwrd">sealed</span> <span class="kwrd">class</span> ListEntry
    {
        <span class="rem">// Fields</span>
        <span class="kwrd">internal</span> Delegate handler;
        <span class="kwrd">internal</span> <span class="kwrd">object</span> key;
        <span class="kwrd">internal</span> EventHandlerList.ListEntry next;

        <span class="rem">// Methods</span>
        <span class="kwrd">public</span> ListEntry(<span class="kwrd">object</span> key, Delegate handler, EventHandlerList.ListEntry next)
        {
            <span class="kwrd">this</span>.next = next;
            <span class="kwrd">this</span>.key = key;
            <span class="kwrd">this</span>.handler = handler;
        }
    }
}


所以,既然是通过线性表来保存的，那么就有一个先后顺序的情况。其实，一个更好的写法是下面这样的</pre><pre class="csharpcode">&nbsp;</pre><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;
<span class="kwrd">using</span> System.Reflection;

<span class="kwrd">using</span> System.Threading;
<span class="kwrd">using</span> System.ComponentModel;
<span class="kwrd">namespace</span> ConsoleApplication1
{
    <span class="kwrd">class</span> Program
    {
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">///这个例子解释了如果为一个事件绑定了多个事件处理程序，那么他们处理的顺序与绑定顺序是一致的</span>

            Console.WriteLine(<span class="str">"主线程号是:{0}"</span>, Thread.CurrentThread.ManagedThreadId);

            Employee e = <span class="kwrd">new</span> Employee();
            e.NameChanged += <span class="kwrd">new</span> EventHandler(e_NameChanged);
            e.NameChanged += <span class="kwrd">new</span> EventHandler(e_NameChanged2);

            
            e.Name = <span class="str">"ares chen"</span>;

            Console.Read();
        }

        <span class="kwrd">static</span> <span class="kwrd">void</span> e_NameChanged2(<span class="kwrd">object</span> sender, EventArgs e)
        {
            
            Console.WriteLine(<span class="str">"第2个事件处理程序触发的时间是:{0}"</span>, DateTime.Now);
            Console.WriteLine(<span class="str">"当前线程号是:{0}"</span>, Thread.CurrentThread.ManagedThreadId);
        }

        <span class="kwrd">static</span> <span class="kwrd">void</span> e_NameChanged(<span class="kwrd">object</span> sender, EventArgs e)
        {
            Console.WriteLine(<span class="str">"第1个事件处理程序触发的时间是:{0}"</span>, DateTime.Now);
            Console.WriteLine(<span class="str">"当前线程号是:{0}"</span>, Thread.CurrentThread.ManagedThreadId);            
        }
    }


    <span class="kwrd">class</span> Employee
    {
        <span class="rem">//public event EventHandler NameChanged;</span>

<strong><font size="4">        <span class="kwrd">protected</span> EventHandlerList listEventDelegates = <span class="kwrd">new</span> EventHandlerList();
        <span class="kwrd">private</span> <span class="kwrd">object</span> NameChangedEventKey = <span class="kwrd">new</span> <span class="kwrd">object</span>();

        <span class="kwrd">public</span> <span class="kwrd">event</span> EventHandler NameChanged {
            add {
                listEventDelegates.AddHandler(NameChangedEventKey, <span class="kwrd">value</span>);
            }
            remove {
                listEventDelegates.RemoveHandler(NameChangedEventKey, <span class="kwrd">value</span>);
            }
        }</font></strong>

        <span class="kwrd">private</span> <span class="kwrd">string</span> name;
        <span class="kwrd">public</span> <span class="kwrd">string</span> Name
        {
            get
            {
                <span class="kwrd">return</span> name;
            }
            set
            {
                name = <span class="kwrd">value</span>;


<strong><font size="4">                <span class="kwrd">if</span> (listEventDelegates[NameChangedEventKey] != <span class="kwrd">null</span>) {
                    listEventDelegates[NameChangedEventKey].DynamicInvoke(<span class="kwrd">new</span> <span class="kwrd">object</span>[] { <span class="kwrd">this</span>, <span class="kwrd">null</span> });
                }</font></strong>
            }
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>&nbsp;</p>
<p>为什么使用EventHandlerList？ 这个问题之前就谈论过，默认情况下，客户端程序每为事件绑定一个处理程序，就需要在类型中产生一个delegate的引用，如此一来，如果事件很多的话，不利于较好地控制内存。但如果用EventHandlerList的话，则有利于统一管理所有的delegate</p>