# WPF：如何在工作线程中更新窗体的UI元素（Dispatcher机制） 
> 原文发表于 2010-03-25, 地址: http://www.cnblogs.com/chenxizhang/archive/2010/03/25/1694604.html 


<p>这是一个普遍的问题：如果我们再程序中使用了多线程技术，而工作线程（后台线程）如果需要更新界面上的元素（例如进度条等），就会有一个线程安全性问题，因为进度条是由主线程创建出来的。</p> <p>关于这一点，大致上看，WPF的机制与Windows Forms是没有差别的。我们在Windows Forms中需要按照下面的方式更新窗体元素。</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_2.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_thumb.png" width="304" height="207"></a> </p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Windows.Forms;
<span class="kwrd">using</span> System.Threading;

<span class="kwrd">namespace</span> WindowsFormsApplication1
{
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> Form1 : Form
    {
        <span class="kwrd">public</span> Form1()
        {
            InitializeComponent();
        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> button1_Click(<span class="kwrd">object</span> sender, EventArgs e)
        {
            <span class="rem">//错误的写法：直接更新</span>
            <span class="kwrd">new</span> Thread(() =&gt;
            {
                progressBar1.Value = 10;
            }).Start();


        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> button2_Click(<span class="kwrd">object</span> sender, EventArgs e)
        {
            <span class="rem">//正确的写法，通知主线程更新</span>
            <span class="kwrd">new</span> Thread(()=&gt;{
                <span class="kwrd">this</span>.Invoke(<span class="kwrd">new</span> Action(() =&gt;
                {
                    progressBar1.Value = 10;
                }));
            }).Start();
        }
    }
}
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
第一种是错误的写法，它将导致一个运行时错误</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_4.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_thumb_1.png" width="456" height="241"></a> </p>
<p>&nbsp;</p>
<p>了解了这些，我们来看看WPF是怎么做的？</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_6.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_thumb_2.png" width="445" height="261"></a> </p>
<p>点击第一个按钮的话，我们同样会收到一个错误</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_8.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_thumb_3.png" width="456" height="241"></a> </p>
<p>点击第二个按钮，则工作正常</p>
<p></p>
<p></p>
<p></p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_10.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_thumb_4.png" width="445" height="261"></a> </p>
<p>我们看看代码有什么区别</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Windows;
<span class="kwrd">using</span> System.Threading;

<span class="kwrd">namespace</span> WpfApplication1
{
    <span class="rem">/// &lt;summary&gt;</span>
    <span class="rem">/// Window1.xaml 的交互逻辑</span>
    <span class="rem">/// &lt;/summary&gt;</span>
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> Window1 : Window
    {
        <span class="kwrd">public</span> Window1()
        {
            InitializeComponent();
        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> button1_Click(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {
            <span class="rem">//错误的写法：直接更新</span>
            <span class="kwrd">new</span> Thread(() =&gt;
            {
                progressBar1.Value = 20;
            }).Start();

        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> button2_Click(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {
            <span class="rem">//正确的写法：通知主线程去完成更新</span>
            <span class="kwrd">new</span> Thread(()=&gt;{
                <span class="kwrd">this</span>.Dispatcher.Invoke(<span class="kwrd">new</span> Action(()=&gt;{
                    progressBar1.Value=20;
                }));
            }).Start();
        }
    }
}
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
请注意，Window类并没有Invoke方法，这是与Form不一样的。取而代之的是，我们需要通过访问Window.Dispatcher属性，然后调用Invoke方法 。仅此而已</p>
<p>&nbsp;</p>
<p>好吧，那么到底什么是Dispatcher呢？从字面上来说，它是所谓的接线员，或者调度员的意思。这说明什么呢？每个线程都有一个唯一的调度员，我们在代码中所做的工作其实是向这个调度员发出指令，然后它再帮我们做。这样理解就对了。</p>
<p>我们的窗体是在主线程创建出来的，里面的控件自然也是如此。我们之前解释过WPF的应用程序也是单线程模型的(STAThread)，所以整个应用程序里面会有一个默认的Dispatcher，它负责调度主线程的工作。</p>
<p>其实，如果大家真有兴趣，可以看看Application.Run这个方法的实现，就能理解上面所说的话了</p><pre class="csharpcode">[SecurityCritical]
<span class="kwrd">internal</span> <span class="kwrd">int</span> RunInternal(Window window)
{
    <span class="kwrd">base</span>.VerifyAccess();
    EventTrace.NormalTraceEvent(EventTraceGuidId.APPRUNGUID, 0);
    <span class="kwrd">if</span> (<span class="kwrd">this</span>._appIsShutdown)
    {
        <span class="kwrd">throw</span> <span class="kwrd">new</span> InvalidOperationException(SR.Get(<span class="str">"CannotCallRunMultipleTimes"</span>, <span class="kwrd">new</span> <span class="kwrd">object</span>[] { <span class="kwrd">base</span>.GetType().FullName }));
    }
    <span class="kwrd">if</span> (window != <span class="kwrd">null</span>)
    {
        <span class="kwrd">if</span> (!window.CheckAccess())
        {
            <span class="kwrd">throw</span> <span class="kwrd">new</span> ArgumentException(SR.Get(<span class="str">"WindowPassedShouldBeOnApplicationThread"</span>, <span class="kwrd">new</span> <span class="kwrd">object</span>[] { window.GetType().FullName, <span class="kwrd">base</span>.GetType().FullName }));
        }
        <span class="kwrd">if</span> (!<span class="kwrd">this</span>.WindowsInternal.HasItem(window))
        {
            <span class="kwrd">this</span>.WindowsInternal.Add(window);
        }
        <span class="kwrd">if</span> (<span class="kwrd">this</span>.MainWindow == <span class="kwrd">null</span>)
        {
            <span class="kwrd">this</span>.MainWindow = window;
        }
        <span class="kwrd">if</span> (window.Visibility != Visibility.Visible)
        {
            <span class="kwrd">base</span>.Dispatcher.BeginInvoke(DispatcherPriority.Send, <span class="kwrd">delegate</span> (<span class="kwrd">object</span> obj) {
                (obj <span class="kwrd">as</span> Window).Show();
                <span class="kwrd">return</span> <span class="kwrd">null</span>;
            }, window);
        }
    }
    <span class="kwrd">this</span>.EnsureHwndSource();
    <span class="kwrd">if</span> (!BrowserInteropHelper.IsBrowserHosted)
    {
        <span class="kwrd">this</span>.RunDispatcher(<span class="kwrd">null</span>);
    }
    <span class="kwrd">return</span> <span class="kwrd">this</span>._exitCode;
}

 
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
<pre class="csharpcode">[SecurityCritical]
<span class="kwrd">private</span> <span class="kwrd">object</span> RunDispatcher(<span class="kwrd">object</span> ignore)
{
    Invariant.Assert(!<span class="kwrd">this</span>._ownDispatcherStarted);
    <span class="kwrd">this</span>._ownDispatcherStarted = <span class="kwrd">true</span>;
    Dispatcher.Run();
    <span class="kwrd">return</span> <span class="kwrd">null</span>;
}

 
那么，为什么在Window中可以调用到Dispatcher属性呢？或者说在那些对象上面可以采用这种机制呢？大致上说，几乎所有的控件都可以，因为他们的基类一般都可以追溯到一个DispatcherObject</pre><pre class="csharpcode"><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_12.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_thumb_5.png" width="215" height="81"></a>  
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_14.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_thumb_6.png" width="419" height="281"></a> </p>
<p>&nbsp;</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_16.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFUIDispatcher_7A73/image_thumb_7.png" width="413" height="301"></a>&nbsp;</p>
<p>从这个角度来说，如果我们自己编写一个用于WPF的控件，那么也是需要按照这样的层次结构去继承的。这样在控件内部，才可以通过this.Dispatcher来更新一些界面元素了。</p>
<p>那么，如果我们是一个类库项目，就是一个标准的类型，它也需要更新到主线程中的一些元素怎么办？</p>
<p>此时可以通过Application.Current.Dispacther来实现，例如下面的例子</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Windows;

<span class="kwrd">namespace</span> WpfApplication1
{
    <span class="kwrd">public</span> <span class="kwrd">class</span> WindowHelper
    {
        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">void</span> SomeMethod() {
            Application.Current.Dispatcher.Invoke(<span class="kwrd">new</span> Action(() =&gt; {
                Application.Current.MainWindow.Title = <span class="str">"我修改过的窗体标题"</span>;
            }));
        }
    }
}
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
其实，要认真讲的话，Application的这个Dispatcher与我们刚才用到的Window的Dispatcher是同一个对象。也就是说，每个线程只有一个。</p>
<p>而其实，使用Window的Dispatcher，与使用Button的Dispatcher也没有区别的</p>
<p>&nbsp;</p>
<p>最后要说一点的是，Dispatcher除了Invoke方法之外，还有BeginInvoke方法。区别在于后者是异步执行的。如何使用异步的机制呢？</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Windows;
<span class="kwrd">using</span> System.Windows.Threading;

<span class="kwrd">namespace</span> WpfApplication1
{
    <span class="kwrd">public</span> <span class="kwrd">class</span> WindowHelper
    {
        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">void</span> SomeMethod() {
            <span class="rem">//Application.Current.Dispatcher.Invoke(new Action(() =&gt; {</span>
            <span class="rem">//    Application.Current.MainWindow.Title = "我修改过的窗体标题";</span>
            <span class="rem">//}));</span>


            var task = Application.Current.Dispatcher.BeginInvoke(<span class="kwrd">new</span> Action(() =&gt; { Application.Current.MainWindow.Title = <span class="str">"我修改过的窗体标题"</span>; }));
            task.Completed += <span class="kwrd">new</span> EventHandler(task_Completed);
            
        }

        <span class="kwrd">static</span> <span class="kwrd">void</span> task_Completed(<span class="kwrd">object</span> sender, EventArgs e)
        {
            MessageBox.Show(<span class="str">"任务已经完成"</span>);
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>