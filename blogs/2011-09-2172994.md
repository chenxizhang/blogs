# 你得学会并且学得会的Socket编程基础知识 
> 原文发表于 2011-09-10, 地址: http://www.cnblogs.com/chenxizhang/archive/2011/09/10/2172994.html 


<p>这一篇文章，我将图文并茂地介绍Socket编程的基础知识，我相信，如果你按照步骤做完实验，一定可以对Socket编程有更好地理解。</p> <p>本文源代码，可以通过这里下载 <a title="http://files.cnblogs.com/chenxizhang/SocketWorkshop.rar" href="http://files.cnblogs.com/chenxizhang/SocketWorkshop.rar">http://files.cnblogs.com/chenxizhang/SocketWorkshop.rar</a></p> <p>&nbsp;</p> <h1>第一步：创建解决方案</h1> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924291243.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924293228.png" width="959" height="664"></a></p> <h1>第二步：创建服务端程序</h1> <p>这里可以选择“Console Application”这个类型，比较方便调试</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924294341.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924307962.png" width="959" height="664"></a></p> <p>然后编写如下代码，实现服务器的基本功能</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="rem">//额外导入的两个命名空间</span>
<span class="kwrd">using</span> System.Net.Sockets;
<span class="kwrd">using</span> System.Net;

<span class="kwrd">namespace</span> SocketServer
{
    <span class="kwrd">class</span> Program
    {
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// Socket Server 演示</span>
        <span class="rem">/// 作者：陈希章</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="args"&gt;&lt;/param&gt;</span>
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">//创建一个新的Socket,这里我们使用最常用的基于TCP的Stream Socket（流式套接字）</span>
            var socket = <span class="kwrd">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            <span class="rem">//将该socket绑定到主机上面的某个端口</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.bind.aspx</span>
            socket.Bind(<span class="kwrd">new</span> IPEndPoint(IPAddress.Any, 4530));

            <span class="rem">//启动监听，并且设置一个最大的队列长度</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.listen(v=VS.100).aspx</span>
            socket.Listen(4);


            Console.WriteLine(<span class="str">"Server is ready!"</span>);
            Console.Read();
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>


<p>&nbsp;</p>
<p>现在可以启动调试一下看看效果如何，正常情况下应该会看到一个提示，因为我们需要在TCP 4530端口进行监听，所以防火墙会有提示。</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924301342.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924309423.png" width="545" height="391"></a></p>
<p>点击“Allow access”</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924308900.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924313916.png" width="681" height="446"></a></p>
<p>这样，我们的服务器就可以开始监听了。但是这有什么用呢？是的，没有什么用。</p>
<p>我们还需要为服务器添加一些功能，例如接受传入的请求，给客户端发送消息，或者从客户端接收消息等等</p>
<h1>第三步：接受传入的请求</h1>
<p>我们需要通过Accept，或者(BeginAccept)来接受传入的请求，请注意下面代码中的红色部分</p>
<p>&nbsp;</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="rem">//额外导入的两个命名空间</span>
<span class="kwrd">using</span> System.Net.Sockets;
<span class="kwrd">using</span> System.Net;

<span class="kwrd">namespace</span> SocketServer
{
    <span class="kwrd">class</span> Program
    {
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// Socket Server 演示</span>
        <span class="rem">/// 作者：陈希章</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="args"&gt;&lt;/param&gt;</span>
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">//创建一个新的Socket,这里我们使用最常用的基于TCP的Stream Socket（流式套接字）</span>
            var socket = <span class="kwrd">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            <span class="rem">//将该socket绑定到主机上面的某个端口</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.bind.aspx</span>
            socket.Bind(<span class="kwrd">new</span> IPEndPoint(IPAddress.Any, 4530));

            <span class="rem">//启动监听，并且设置一个最大的队列长度</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.listen(v=VS.100).aspx</span>
            socket.Listen(4);

<strong><font color="#ff0000">            <span class="rem">//开始接受客户端连接请求</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.beginaccept.aspx</span>
            socket.BeginAccept(<span class="kwrd">new</span> AsyncCallback((ar) =&gt;
            {
                <span class="rem">//这就是客户端的Socket实例，我们后续可以将其保存起来</span>
                var client = socket.EndAccept(ar);

                <span class="rem">//给客户端发送一个欢迎消息</span>
                client.Send(Encoding.Unicode.GetBytes(<span class="str">"Hi there, I accept you request at "</span>+DateTime.Now.ToString()));
            }), <span class="kwrd">null</span>);</font></strong>


            Console.WriteLine(<span class="str">"Server is ready!"</span>);
            Console.Read();
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>


<p>&nbsp;</p>
<p>wow，看起来不错对吧，我们赶紧做一个客户端来测试一下吧</p>
<p>&nbsp;</p>
<h1>第四步：创建客户端</h1>
<p>我们还是使用一个Console Application</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924316981.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924314506.png" width="959" height="664"></a></p>
<p>添加如下的代码，并且创建客户端连接</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="rem">//导入的命名空间</span>
<span class="kwrd">using</span> System.Net.Sockets;

<span class="kwrd">namespace</span> SocketClient
{
    <span class="kwrd">class</span> Program
    {
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// Socket Server 演示</span>
        <span class="rem">/// 作者：陈希章</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="args"&gt;&lt;/param&gt;</span>
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">//创建一个Socket</span>
            var socket = <span class="kwrd">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            <span class="rem">//连接到指定服务器的指定端口</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.connect.aspx</span>
            socket.Connect(<span class="str">"localhost"</span>, 4530);


            Console.WriteLine(<span class="str">"connect to the server"</span>);
            Console.Read();

        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>依次选择SocketServer和SocketClient这两个项目，分别将其启动为调试状态（右键菜单，Debug=&gt;Start new instance)</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924313110.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924318127.png" width="693" height="193"></a></p>
<p>我们看到两个程序都工作正常。</p>
<p>但是，在客户端怎么没有收到服务器发过来的消息呢？那是因为，我们没有在客户端提供这方面的功能。</p>
<p>&nbsp;</p>
<h1>第五步：在客户端中实现接受消息的方法</h1><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="rem">//导入的命名空间</span>
<span class="kwrd">using</span> System.Net.Sockets;

<span class="kwrd">namespace</span> SocketClient
{
    <span class="kwrd">class</span> Program
    {
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// Socket Server 演示</span>
        <span class="rem">/// 作者：陈希章</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="args"&gt;&lt;/param&gt;</span>
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">//创建一个Socket</span>
            var socket = <span class="kwrd">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            <span class="rem">//连接到指定服务器的指定端口</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.connect.aspx</span>
            socket.Connect(<span class="str">"localhost"</span>, 4530);

            <span class="rem">//实现接受消息的方法</span>

<strong><font color="#ff0000">            var buffer = <span class="kwrd">new</span> <span class="kwrd">byte</span>[1024];<span class="rem">//设置一个缓冲区，用来保存数据</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.beginreceive.aspx</span>
            socket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, <span class="kwrd">new</span> AsyncCallback((ar) =&gt;
            {
                <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.endreceive.aspx</span>
                var length = socket.EndReceive(ar);
                <span class="rem">//读取出来消息内容</span>
                var message = Encoding.Unicode.GetString(buffer, 0, length);
                <span class="rem">//显示消息</span>
                Console.WriteLine(message);

            }), <span class="kwrd">null</span>);</font></strong>

            Console.WriteLine(<span class="str">"connect to the server"</span>);
            Console.Read();

        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>请注意以上红色的部分，我们用了BeginReceive方法进行异步的消息侦听，如果收到了，我们就打印出来</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924311507.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/20110910092432112.png" width="673" height="187"></a></p>
<p>看起来已经实现了我们需求了：服务器给客户端发了一个消息，而客户端也已经收到了。</p>
<p>但是，这远远不够，因为它们之间的通讯不仅仅是一次性的，那么如果服务器要不断地给客户端发消息，例如每隔两秒钟就发送一个消息，如何实现呢？</p>
<p>&nbsp;</p>
<h1>第六步：实现服务器定期向客户端发消息</h1><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="rem">//额外导入的两个命名空间</span>
<span class="kwrd">using</span> System.Net.Sockets;
<span class="kwrd">using</span> System.Net;

<span class="kwrd">namespace</span> SocketServer
{
    <span class="kwrd">class</span> Program
    {
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// Socket Server 演示</span>
        <span class="rem">/// 作者：陈希章</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="args"&gt;&lt;/param&gt;</span>
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">//创建一个新的Socket,这里我们使用最常用的基于TCP的Stream Socket（流式套接字）</span>
            var socket = <span class="kwrd">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            <span class="rem">//将该socket绑定到主机上面的某个端口</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.bind.aspx</span>
            socket.Bind(<span class="kwrd">new</span> IPEndPoint(IPAddress.Any, 4530));

            <span class="rem">//启动监听，并且设置一个最大的队列长度</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.listen(v=VS.100).aspx</span>
            socket.Listen(4);

            <span class="rem">//开始接受客户端连接请求</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.beginaccept.aspx</span>
            socket.BeginAccept(<span class="kwrd">new</span> AsyncCallback((ar) =&gt;
            {
                <span class="rem">//这就是客户端的Socket实例，我们后续可以将其保存起来</span>
                var client = socket.EndAccept(ar);

                <span class="rem">//给客户端发送一个欢迎消息</span>
                client.Send(Encoding.Unicode.GetBytes(<span class="str">"Hi there, I accept you request at "</span>+DateTime.Now.ToString()));


<strong><font color="#ff0000">                <span class="rem">//实现每隔两秒钟给服务器发一个消息</span>
                <span class="rem">//这里我们使用了一个定时器</span>
                var timer = <span class="kwrd">new</span> System.Timers.Timer();
                timer.Interval = 2000D;
                timer.Enabled = <span class="kwrd">true</span>;
                timer.Elapsed += (o, a) =&gt;
                {
                    client.Send(Encoding.Unicode.GetBytes(<span class="str">"Message from server at "</span> +DateTime.Now.ToString()));
                };
                timer.Start();</font></strong>

            }), <span class="kwrd">null</span>);


            Console.WriteLine(<span class="str">"Server is ready!"</span>);
            Console.Read();
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>



<p>&nbsp;</p>
<p>我们还要实现在客户端一直监听消息的机制，而不是一次性接收.请注意下面红色的部分</p>
<p>&nbsp;</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="rem">//导入的命名空间</span>
<span class="kwrd">using</span> System.Net.Sockets;

<span class="kwrd">namespace</span> SocketClient
{
    <span class="kwrd">class</span> Program
    {
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// Socket Server 演示</span>
        <span class="rem">/// 作者：陈希章</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="args"&gt;&lt;/param&gt;</span>
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">//创建一个Socket</span>
            var socket = <span class="kwrd">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            <span class="rem">//连接到指定服务器的指定端口</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.connect.aspx</span>
            socket.Connect(<span class="str">"localhost"</span>, 4530);
            Console.WriteLine(<span class="str">"connect to the server"</span>);

            <span class="rem">//实现接受消息的方法</span>

            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.beginreceive.aspx</span>
           <strong><font color="#ff0000"> socket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, <span class="kwrd">new</span> AsyncCallback(ReceiveMessage),socket);</font></strong>

            Console.Read();

        }


<font color="#ff0000"><strong>        <span class="kwrd">static</span> <span class="kwrd">byte</span>[] buffer = <span class="kwrd">new</span> <span class="kwrd">byte</span>[1024];

        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">void</span> ReceiveMessage(IAsyncResult ar)
        {
            <span class="kwrd">try</span>
            {
                var socket = ar.AsyncState <span class="kwrd">as</span> Socket;

                <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.endreceive.aspx</span>
                var length = socket.EndReceive(ar);
                <span class="rem">//读取出来消息内容</span>
                var message = Encoding.Unicode.GetString(buffer, 0, length);
                <span class="rem">//显示消息</span>
                Console.WriteLine(message);

                <span class="rem">//接收下一个消息(因为这是一个递归的调用，所以这样就可以一直接收消息了）</span>
                socket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, <span class="kwrd">new</span> AsyncCallback(ReceiveMessage), socket);
            }
            <span class="kwrd">catch</span>(Exception ex){
                Console.WriteLine(ex.Message);
            }
        }</strong></font>
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>重新调试起来，看起来的效果如下图所示</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924321540.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924326557.png" width="678" height="416"></a></p>
<p>我们继续做下面的实验，一步一步地研究Socket通讯中可能遇到的一些问题</p>
<p><strong>请先关闭掉客户端这个程序，而不要关闭服务端程序</strong>，这时会发现一个错误</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924321573.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924328542.png" width="856" height="454"></a></p>
<p>这个错误很容易理解，因为客户端已经关闭，也就是客户端那个Socket已经不存在了，服务器还继续向它发送消息当然会出错。所以，从可靠性方面的考虑，我们必须在发送消息之前检测Socket的活动状态</p>
<p>&nbsp;</p>
<h1>第七步：检测客户端的活动状态</h1><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="rem">//额外导入的两个命名空间</span>
<span class="kwrd">using</span> System.Net.Sockets;
<span class="kwrd">using</span> System.Net;

<span class="kwrd">namespace</span> SocketServer
{
    <span class="kwrd">class</span> Program
    {
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// Socket Server 演示</span>
        <span class="rem">/// 作者：陈希章</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="args"&gt;&lt;/param&gt;</span>
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">//创建一个新的Socket,这里我们使用最常用的基于TCP的Stream Socket（流式套接字）</span>
            var socket = <span class="kwrd">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            <span class="rem">//将该socket绑定到主机上面的某个端口</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.bind.aspx</span>
            socket.Bind(<span class="kwrd">new</span> IPEndPoint(IPAddress.Any, 4530));

            <span class="rem">//启动监听，并且设置一个最大的队列长度</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.listen(v=VS.100).aspx</span>
            socket.Listen(4);

            <span class="rem">//开始接受客户端连接请求</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.beginaccept.aspx</span>
            socket.BeginAccept(<span class="kwrd">new</span> AsyncCallback((ar) =&gt;
            {
                <span class="rem">//这就是客户端的Socket实例，我们后续可以将其保存起来</span>
                var client = socket.EndAccept(ar);

                <span class="rem">//给客户端发送一个欢迎消息</span>
                client.Send(Encoding.Unicode.GetBytes(<span class="str">"Hi there, I accept you request at "</span>+DateTime.Now.ToString()));


                <span class="rem">//实现每隔两秒钟给服务器发一个消息</span>
                <span class="rem">//这里我们使用了一个定时器</span>
                var timer = <span class="kwrd">new</span> System.Timers.Timer();
                timer.Interval = 2000D;
                timer.Enabled = <span class="kwrd">true</span>;
                timer.Elapsed += (o, a) =&gt;
                {
<strong><font color="#ff0000">                    <span class="rem">//检测客户端Socket的状态</span>
                    <span class="kwrd">if</span>(client.Connected)
                    {
                        <span class="kwrd">try</span>
                        {
                            client.Send(Encoding.Unicode.GetBytes(<span class="str">"Message from server at "</span> + DateTime.Now.ToString()));
                        }
                        <span class="kwrd">catch</span>(SocketException ex)
                        {
                            Console.WriteLine(ex.Message);
                        }
                    }
                    <span class="kwrd">else</span>
                    {
                        timer.Stop();
                        timer.Enabled = <span class="kwrd">false</span>;
                        Console.WriteLine(<span class="str">"Client is disconnected, the timer is stop."</span>);
                    }</font></strong>
                };
                timer.Start();

            }), <span class="kwrd">null</span>);


            Console.WriteLine(<span class="str">"Server is ready!"</span>);
            Console.Read();
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>上面代码的逻辑很清楚，但有时候还是会触发那个SocketException。为什么呢？这是因为我们的Timer是每隔两秒钟检查一次，那么就很可能有一种情况，我们检查的时候，它还是连接状态，消息发出去之后，它断开了。这种情况肯定是存在的。所以要用Try..catch的结构</p>
<p>&nbsp;</p>
<p>目前我们实现的场景很简单，服务器只管发消息，客户端只管收消息。但实际工作中，可能希望服务器和客户端都能收发消息。请看下一节</p>
<p>&nbsp;</p>
<h1>第八步：实现双向收发消息</h1>
<p>先看服务端的修改</p>
<p>&nbsp;</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="rem">//额外导入的两个命名空间</span>
<span class="kwrd">using</span> System.Net.Sockets;
<span class="kwrd">using</span> System.Net;

<span class="kwrd">namespace</span> SocketServer
{
    <span class="kwrd">class</span> Program
    {
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// Socket Server 演示</span>
        <span class="rem">/// 作者：陈希章</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="args"&gt;&lt;/param&gt;</span>
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">//创建一个新的Socket,这里我们使用最常用的基于TCP的Stream Socket（流式套接字）</span>
            var socket = <span class="kwrd">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            <span class="rem">//将该socket绑定到主机上面的某个端口</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.bind.aspx</span>
            socket.Bind(<span class="kwrd">new</span> IPEndPoint(IPAddress.Any, 4530));

            <span class="rem">//启动监听，并且设置一个最大的队列长度</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.listen(v=VS.100).aspx</span>
            socket.Listen(4);

            <span class="rem">//开始接受客户端连接请求</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.beginaccept.aspx</span>
            socket.BeginAccept(<span class="kwrd">new</span> AsyncCallback((ar) =&gt;
            {
                <span class="rem">//这就是客户端的Socket实例，我们后续可以将其保存起来</span>
                var client = socket.EndAccept(ar);

                <span class="rem">//给客户端发送一个欢迎消息</span>
                client.Send(Encoding.Unicode.GetBytes(<span class="str">"Hi there, I accept you request at "</span>+DateTime.Now.ToString()));


                <span class="rem">//实现每隔两秒钟给服务器发一个消息</span>
                <span class="rem">//这里我们使用了一个定时器</span>
                var timer = <span class="kwrd">new</span> System.Timers.Timer();
                timer.Interval = 2000D;
                timer.Enabled = <span class="kwrd">true</span>;
                timer.Elapsed += (o, a) =&gt;
                {
                    <span class="rem">//检测客户端Socket的状态</span>
                    <span class="kwrd">if</span>(client.Connected)
                    {
                        <span class="kwrd">try</span>
                        {
                            client.Send(Encoding.Unicode.GetBytes(<span class="str">"Message from server at "</span> + DateTime.Now.ToString()));
                        }
                        <span class="kwrd">catch</span>(SocketException ex)
                        {
                            Console.WriteLine(ex.Message);
                        }
                    }
                    <span class="kwrd">else</span>
                    {
                        timer.Stop();
                        timer.Enabled = <span class="kwrd">false</span>;
                        Console.WriteLine(<span class="str">"Client is disconnected, the timer is stop."</span>);
                    }
                };
                timer.Start();


  <strong><font color="#ff0000">              <span class="rem">//接收客户端的消息(这个和在客户端实现的方式是一样的）</span>
                client.BeginReceive(buffer,0,buffer.Length,SocketFlags.None,<span class="kwrd">new</span> AsyncCallback(ReceiveMessage),client);</font></strong>

            }), <span class="kwrd">null</span>);


            Console.WriteLine(<span class="str">"Server is ready!"</span>);
            Console.Read();
        }

<strong><font color="#ff0000">        <span class="kwrd">static</span> <span class="kwrd">byte</span>[] buffer = <span class="kwrd">new</span> <span class="kwrd">byte</span>[1024];

        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">void</span> ReceiveMessage(IAsyncResult ar)
        {
            <span class="kwrd">try</span>
            {
                var socket = ar.AsyncState <span class="kwrd">as</span> Socket;

                <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.endreceive.aspx</span>
                var length = socket.EndReceive(ar);
                <span class="rem">//读取出来消息内容</span>
                var message = Encoding.Unicode.GetString(buffer, 0, length);
                <span class="rem">//显示消息</span>
                Console.WriteLine(message);

                <span class="rem">//接收下一个消息(因为这是一个递归的调用，所以这样就可以一直接收消息了）</span>
                socket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, <span class="kwrd">new</span> AsyncCallback(ReceiveMessage), socket);
            }
            <span class="kwrd">catch</span>(Exception ex){
                Console.WriteLine(ex.Message);
            }
        }</font></strong>
    }
}
</pre>
<p>可以看出来，为了让服务器可以接受消息，其实并不需要什么特别的设计，与客户端接受消息其实可以是一样的
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>&nbsp;</p>
<p>再来看看客户端的修改</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="rem">//导入的命名空间</span>
<span class="kwrd">using</span> System.Net.Sockets;

<span class="kwrd">namespace</span> SocketClient
{
    <span class="kwrd">class</span> Program
    {
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// Socket Server 演示</span>
        <span class="rem">/// 作者：陈希章</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="args"&gt;&lt;/param&gt;</span>
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">//创建一个Socket</span>
            var socket = <span class="kwrd">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            <span class="rem">//连接到指定服务器的指定端口</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.connect.aspx</span>
            socket.Connect(<span class="str">"localhost"</span>, 4530);
            Console.WriteLine(<span class="str">"connect to the server"</span>);

            <span class="rem">//实现接受消息的方法</span>

            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.beginreceive.aspx</span>
            socket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, <span class="kwrd">new</span> AsyncCallback(ReceiveMessage), socket);

<strong><font color="#ff0000">            <span class="rem">//接受用户输入，将消息发送给服务器端</span>
            <span class="kwrd">while</span>(<span class="kwrd">true</span>)
            {
                var message = <span class="str">"Message from client : "</span> + Console.ReadLine();
                var outputBuffer = Encoding.Unicode.GetBytes(message);
                socket.BeginSend(outputBuffer, 0, outputBuffer.Length, SocketFlags.None, <span class="kwrd">null</span>, <span class="kwrd">null</span>);
            }</font></strong>

        }


        <span class="kwrd">static</span> <span class="kwrd">byte</span>[] buffer = <span class="kwrd">new</span> <span class="kwrd">byte</span>[1024];

        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">void</span> ReceiveMessage(IAsyncResult ar)
        {
            <span class="kwrd">try</span>
            {
                var socket = ar.AsyncState <span class="kwrd">as</span> Socket;

                <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.endreceive.aspx</span>
                var length = socket.EndReceive(ar);
                <span class="rem">//读取出来消息内容</span>
                var message = Encoding.Unicode.GetString(buffer, 0, length);
                <span class="rem">//显示消息</span>
                Console.WriteLine(message);

                <span class="rem">//接收下一个消息(因为这是一个递归的调用，所以这样就可以一直接收消息了）</span>
                socket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, <span class="kwrd">new</span> AsyncCallback(ReceiveMessage), socket);
            }
            <span class="kwrd">catch</span>(Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>我在这里做了一个死循环，用户可以不断地输入，这些消息会被发送给服务器。如下图所示</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924325194.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924337212.png" width="682" height="481"></a></p>
<p>【备注】因为服务器每隔两秒钟会发送新消息过来，所以在输入的时候，动作要稍快一点啦</p>
<p>&nbsp;</p>
<p>本文最后探讨一个问题，就是如何让我们的服务器可以支持多个客户端</p>
<p>&nbsp;</p>
<h1>第九步：支持多个客户端</h1>
<p>这个步骤只需要修改服务端程序即可</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="rem">//额外导入的两个命名空间</span>
<span class="kwrd">using</span> System.Net.Sockets;
<span class="kwrd">using</span> System.Net;

<span class="kwrd">namespace</span> SocketServer
{
    <span class="kwrd">class</span> Program
    {
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// Socket Server 演示</span>
        <span class="rem">/// 作者：陈希章</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="args"&gt;&lt;/param&gt;</span>
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="rem">//创建一个新的Socket,这里我们使用最常用的基于TCP的Stream Socket（流式套接字）</span>
            var socket = <span class="kwrd">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);

            <span class="rem">//将该socket绑定到主机上面的某个端口</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.bind.aspx</span>
            socket.Bind(<span class="kwrd">new</span> IPEndPoint(IPAddress.Any, 4530));

            <span class="rem">//启动监听，并且设置一个最大的队列长度</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.listen(v=VS.100).aspx</span>
            socket.Listen(4);

            <span class="rem">//开始接受客户端连接请求</span>
            <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.beginaccept.aspx</span>
       <font color="#ff0000"><strong>     socket.BeginAccept(<span class="kwrd">new</span> AsyncCallback(ClientAccepted), socket);</strong></font>


            Console.WriteLine(<span class="str">"Server is ready!"</span>);
            Console.Read();
        }


<strong><font color="#ff0000">        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">void</span> ClientAccepted(IAsyncResult ar)
        {

            var socket = ar.AsyncState <span class="kwrd">as</span> Socket;

            <span class="rem">//这就是客户端的Socket实例，我们后续可以将其保存起来</span>
            var client = socket.EndAccept(ar);

            <span class="rem">//给客户端发送一个欢迎消息</span>
            client.Send(Encoding.Unicode.GetBytes(<span class="str">"Hi there, I accept you request at "</span> + DateTime.Now.ToString()));


            <span class="rem">//实现每隔两秒钟给服务器发一个消息</span>
            <span class="rem">//这里我们使用了一个定时器</span>
            var timer = <span class="kwrd">new</span> System.Timers.Timer();
            timer.Interval = 2000D;
            timer.Enabled = <span class="kwrd">true</span>;
            timer.Elapsed += (o, a) =&gt;
            {
                <span class="rem">//检测客户端Socket的状态</span>
                <span class="kwrd">if</span>(client.Connected)
                {
                    <span class="kwrd">try</span>
                    {
                        client.Send(Encoding.Unicode.GetBytes(<span class="str">"Message from server at "</span> + DateTime.Now.ToString()));
                    }
                    <span class="kwrd">catch</span>(SocketException ex)
                    {
                        Console.WriteLine(ex.Message);
                    }
                }
                <span class="kwrd">else</span>
                {
                    timer.Stop();
                    timer.Enabled = <span class="kwrd">false</span>;
                    Console.WriteLine(<span class="str">"Client is disconnected, the timer is stop."</span>);
                }
            };
            timer.Start();


            <span class="rem">//接收客户端的消息(这个和在客户端实现的方式是一样的）</span>
            client.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, <span class="kwrd">new</span> AsyncCallback(ReceiveMessage), client);

            <span class="rem">//准备接受下一个客户端请求</span>
            socket.BeginAccept(<span class="kwrd">new</span> AsyncCallback(ClientAccepted), socket);
        }</font></strong>

        <span class="kwrd">static</span> <span class="kwrd">byte</span>[] buffer = <span class="kwrd">new</span> <span class="kwrd">byte</span>[1024];

        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">void</span> ReceiveMessage(IAsyncResult ar)
        {

            <span class="kwrd">try</span>
            {
                var socket = ar.AsyncState <span class="kwrd">as</span> Socket;

                <span class="rem">//方法参考：http://msdn.microsoft.com/zh-cn/library/system.net.sockets.socket.endreceive.aspx</span>
                var length = socket.EndReceive(ar);
                <span class="rem">//读取出来消息内容</span>
                var message = Encoding.Unicode.GetString(buffer, 0, length);
                <span class="rem">//显示消息</span>
                Console.WriteLine(message);

                <span class="rem">//接收下一个消息(因为这是一个递归的调用，所以这样就可以一直接收消息了）</span>
                socket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, <span class="kwrd">new</span> AsyncCallback(ReceiveMessage), socket);
            }
            <span class="kwrd">catch</span>(Exception ex){
                Console.WriteLine(ex.Message);
            }
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>最后调试起来看到的效果如下图</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924343690.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201109/201109100924345392.png" width="686" height="651"></a></p>
<p>&nbsp;</p>



<p>本文源代码，可以通过这里下载 <a title="http://files.cnblogs.com/chenxizhang/SocketWorkshop.rar" href="http://files.cnblogs.com/chenxizhang/SocketWorkshop.rar">http://files.cnblogs.com/chenxizhang/SocketWorkshop.rar</a></p>