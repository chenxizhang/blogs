# 对微信小程序的生命周期进行扩展 – Typescript 篇 
> 原文发表于 2021-01-15, 地址: http://www.cnblogs.com/chenxizhang/p/14281655.html 


<p>最近利用业余时间倒腾了一个微信小程序，主要目的是横向比较一些业界小程序平台的架构和做法。因为有在其他平台长期的开发经验，对于小程序的一些机制做了一些辩证的思考。例如，小程序的页面，其实不是一个页面，而只是一个方法构造器，甚至整个应用也都只是一个方法而已。这样的情况下，我们以前学到的很多面向对象的经验，例如继承之类的，在这里通通就没有用武之地了。不可否认这样对于一些新手来说，可能是一个不错的设计。但对于我们这种老炮来说，总是有一种要去改造它的冲动。
</p><p>于是，我也就开始思考，看看能否对所有的页面做一个通用的功能，而不是每次在每个页面中都去写一遍。例如，很显然几乎所有的小程序，都会有用户个性化的数据。这个数据其实需要到所有的页面，那么到底怎么加载这个数据呢？我们可以在App.OnLaunch中尝试去加载，但一般加载数据的过程都是异步的，又怎么通知到所有页面说数据加载成功了呢？
</p><p>带着这样的问题，本着能用前人经验就不自己折腾的原则，我在网上搜了一下。下面这一篇文章真是跟我英雄所见略同啊。
</p><p><a href="https://developers.weixin.qq.com/community/develop/article/doc/000a42cdb744b0c00b99eaaba56813">https://developers.weixin.qq.com/community/develop/article/doc/000a42cdb744b0c00b99eaaba56813</a>
	</p><p>利用上述文章提到的思路，基本上能实现我的目的。本文是写了一个Typescript的版本，但荣誉属于上面的这位Stephen同学。
</p><p>我喜欢Typescript, 这不用多说了，至于如何用Typescript 进行微信小程序开发，请参考我的文章 <a href="https://www.cnblogs.com/chenxizhang/p/14265729.html">https://www.cnblogs.com/chenxizhang/p/14265729.html</a>
	</p><p>下面上代码，并交待一些用Typescript时特殊的地方。
</p><p>
 </p><ol><li><div>默认情况下，Typescript版本中Page 构造器是不允许修改的，因为它定义时用的是const，你需要手工修改下面这个文件，将其修改为let
</div><p>
 </p><p><img src="https://img2020.cnblogs.com/blog/9072/202101/9072-20210115134928864-1179412735.png" alt=""/>
			</p></li><li><div>创建一个pagex.ts 文件，当然你可以起任何你想要的名字
</div><p>
 </p><p>const pagex = (Page: WechatMiniprogram.Page.Constructor): WechatMiniprogram.Page.Constructor =&gt; {
</p><p>    return (object: any) =&gt; {
</p><p>        const { onLoaded } = object
</p><p>        //由于我们需要重写onLoad这个默认方法，为了让具体页面还可以定义具体的Load逻辑，我们假定页面需要实现一个onLoaded方法
</p><p>        object.onLoad = function (_options: any) {
</p><p>            //读取用户数据
</p><p>            wx.getUserInfo({
</p><p>                success: res =&gt; {
</p><p>                    if (typeof onLoaded === "function")
</p><p>                        //如果用户定义了这个函数的话，就调用它
</p><p>                        onLoaded.call(this, res.userInfo)
</p><p>                }
</p><p>            })
</p><p>        }
</p><p>        //重写所有页面的分享逻辑，这样不需要在页面中定义了
</p><p>        object.onShareAppMessage = () =&gt; {
</p><p>            return {
</p><p>                title: "转发标题"
</p><p>            }
</p><p>        }
</p><p>
 </p><p>        return Page(object)
</p><p>    }
</p><p>}
</p><p>
 </p><p>const original = Page
</p><p>Page = pagex(original)
</p><p>
 </p><p>
 </p></li><li><div>将这个扩展代码导入到应用中。这个很简单，只需要在App.ts中导入即可。
</div><p>
 </p><p><img src="https://img2020.cnblogs.com/blog/9072/202101/9072-20210115134929486-9828773.png" alt=""/>
			</p><p>
 </p></li><li><div>定义一个页面生命周期的扩展接口，以便提示页面，可以实现onLoaded这个函数
</div><p>
 </p><p><img src="https://img2020.cnblogs.com/blog/9072/202101/9072-20210115134930193-565969315.png" alt=""/>
			</p><p>
 </p><p>
 </p></li><li><div>在具体页面代码中，用如下的方式实现一个自定义的页面构造器
</div><p>
 </p><p><img src="https://img2020.cnblogs.com/blog/9072/202101/9072-20210115134931231-2117010961.png" alt=""/>
			</p></li></ol><p>
 </p><p>    很多事情都是因为你想去做它，然后你就做到了。不要停止思考和尝试。</p>