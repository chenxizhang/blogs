# 线程池(ThreadPool) 
> 原文发表于 2010-03-13, 地址: http://www.cnblogs.com/chenxizhang/archive/2010/03/13/1685245.html 


<p>总结起来说,线程池有如下的特性:</p> <ol> <li>每个进程有一个单独的池,也只有一个</li> <li>每个池初始的线程数是相当于处理器的数目</li> <li>每个池默认的最大线程数是处理器数目的25倍</li> <li>即便所有的线程都不处于空闲状态,但此时又有新任务过来,也不一定会马上创建新线程,而是按照半秒的周期再决定是否创建新线程</li> <li>如果达到了最大的线程数,而且没有空闲的情况,那么如果有新任务,就需要等待</li></ol><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;
<span class="kwrd">using</span> System.Threading;
<span class="kwrd">using</span> Microsoft.Win32;

<span class="kwrd">namespace</span> ConsoleApplication1
{
    <span class="kwrd">class</span> Program
    {
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            <span class="kwrd">int</span> workerThreadCount, completionThreaderCount;
            <span class="rem">//默认为处理器数目，这是为了尽可能少一些线程。我的机器上返回2</span>
            ShowMinThread(<span class="kwrd">out</span> workerThreadCount, <span class="kwrd">out</span> completionThreaderCount);

            <span class="rem">//每个进程都有一个线程池。线程池的默认大小为：每个可用处理器 25 个辅助线程（我的机器返回500），再加上 1000 个 I/O 完成线程。</span>
            ShowMaxThread(<span class="kwrd">ref</span> workerThreadCount, <span class="kwrd">ref</span> completionThreaderCount);

            ShowAvailableThread(<span class="kwrd">ref</span> workerThreadCount, <span class="kwrd">ref</span> completionThreaderCount);
            
            ThreadPool.SetMaxThreads(20, 20);
            ShowMaxThread(<span class="kwrd">ref</span> workerThreadCount, <span class="kwrd">ref</span> completionThreaderCount);
            <span class="rem">//在所有线程池线程都分配到任务后，线程池不会立即开始创建新的空闲线程。为避免向线程分配不必要的堆栈空间，线程池按照一定的时间间隔创建新的空闲线程。该时间间隔目前为半秒，但它在 .NET Framework 的以后版本中可能会更改。</span>


           

            Console.Read();
        }



        <span class="kwrd">private</span> <span class="kwrd">static</span> <span class="kwrd">void</span> ShowAvailableThread(<span class="kwrd">ref</span> <span class="kwrd">int</span> c, <span class="kwrd">ref</span> <span class="kwrd">int</span> d)
        {
            ThreadPool.GetAvailableThreads(<span class="kwrd">out</span> c, <span class="kwrd">out</span> d);
            Console.WriteLine(c);
            Console.WriteLine(d);
        }

        <span class="kwrd">private</span> <span class="kwrd">static</span> <span class="kwrd">void</span> ShowMaxThread(<span class="kwrd">ref</span> <span class="kwrd">int</span> c, <span class="kwrd">ref</span> <span class="kwrd">int</span> d)
        {
            ThreadPool.GetMaxThreads(<span class="kwrd">out</span> c, <span class="kwrd">out</span> d);
            Console.WriteLine(c);
            Console.WriteLine(d);
        }

        <span class="kwrd">private</span> <span class="kwrd">static</span> <span class="kwrd">void</span> ShowMinThread(<span class="kwrd">out</span> <span class="kwrd">int</span> c, <span class="kwrd">out</span> <span class="kwrd">int</span> d)
        {
            ThreadPool.GetMinThreads(<span class="kwrd">out</span> c, <span class="kwrd">out</span> d);
            Console.WriteLine(c);
            Console.WriteLine(d);
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>