# 如何利用Interception简化MVVM中的Model和ViewModel的设计 
> 原文发表于 2011-06-24, 地址: http://www.cnblogs.com/chenxizhang/archive/2011/06/24/2089431.html 


<p>这一篇是“<a href="http://www.cnblogs.com/chenxizhang/archive/2011/06/24/2089392.html">如何利用AOP简化MVVM中Model和ViewModel的设计</a>”一文的姊妹篇。阅读本文之前，请一定要先阅读上一篇，否则你可能对有关问题理解不深。</p> <p>&nbsp;</p> <p>上一篇说到，我们可以用AOP的方式，具体来说，我们使用了一个第三方的框架（PostSharp)来实现了代码注入。PostSharp的方式是静态注入，它是需要改变IL代码的。</p> <p>请看下面这个截图,Customer类型里面的IL代码其实是被改过的。PostSharp会改变Visual Studio的编译行为。</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201106/201106242354538006.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201106/201106242354535531.png" width="962" height="740"></a></p> <p>&nbsp;</p> <p>除了用这种方式之外，是否有其他方法呢？其实是有，我这一篇就给大家介绍另外一种做法：使用微软官方提供的Enterprise Library中的Interception功能（由Unity提供的拦截功能）</p> <p>&nbsp;</p> <p>关于Enterprise Library的介绍和下载，请访问下面的地址</p> <p><a href="http://entlib.codeplex.com/">http://entlib.codeplex.com/</a></p> <p>本文演示的例子，是基于Enterprise Library 5.0</p> <p>&nbsp;</p> <p>我们来看下面的例子。假如我们还有一个Model类型，叫Order，表示订单。我们希望它的代码能像下面这样简练。</p><pre class="csharpcode"><span class="kwrd">using</span> System;

<span class="kwrd">namespace</span> WPFMVVMSample.Models
{
    <span class="kwrd">public</span> <span class="kwrd">class</span> Order:ModelBase
    {
        <span class="kwrd">public</span> <span class="kwrd">int</span> OrderID { get; set; }
        <span class="kwrd">public</span> DateTime OrderDate { get; set; }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>【注意】我们这里只继承了ModelBase，没有其他任何特别的东西。</p>
<p>请放心，我们可以做到。你只要继续往下读就可以了。</p>
<p>&nbsp;</p>
<h2>1. 添加引用</h2>
<p>我们需要引用一个程序集</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201106/201106242354548911.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201106/201106242354546993.png" width="829" height="542"></a></p>
<p>&nbsp;</p>
<h2>2. 编写一个InterceptionBehavior</h2>
<p>Behavior是指我们需要注入的一种行为。这是Interception中的专业术语。</p>
<p>【注意】这一篇文章不是专门来讲Policy Injection的，有兴趣的朋友，可以参考Enterprise Library中的说明文档</p>
<p>&nbsp;</p><pre class="csharpcode"><span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> Microsoft.Practices.Unity.InterceptionExtension;

<span class="kwrd">namespace</span> WPFMVVMSample
{
    <span class="kwrd">public</span> <span class="kwrd">class</span> NotifyPropertyChangedBahavior:IInterceptionBehavior
    {


        <span class="kwrd">public</span> System.Collections.Generic.IEnumerable&lt;System.Type&gt; GetRequiredInterfaces()
        {
            <span class="kwrd">return</span> Enumerable.Empty&lt;System.Type&gt;();

        }

        <span class="kwrd">public</span> IMethodReturn Invoke(IMethodInvocation input, GetNextInterceptionBehaviorDelegate getNext)
        {


            var result= getNext()(input, getNext);<span class="rem">//先执行方法</span>


            var methodName = input.MethodBase.Name;
            var type = input.Target.GetType();
            var targetMethod = type.GetMethod(<span class="str">"OnPropertyChanged"</span>,
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

            <span class="kwrd">if</span> (methodName.StartsWith(<span class="str">"set_"</span>) &amp;&amp; targetMethod != <span class="kwrd">null</span>)<span class="rem">//只针对这种方法器进行注入</span>
            {
                var propertyName = methodName.Substring(4);<span class="rem">//解析得到属性名称</span>
                targetMethod.Invoke(input.Target, <span class="kwrd">new</span>[] { propertyName });<span class="rem">//执行该方法</span>
            }

            <span class="kwrd">return</span> result;
        }

        <span class="kwrd">public</span> <span class="kwrd">bool</span> WillExecute
        {
            get { <span class="kwrd">return</span> <span class="kwrd">true</span>; }
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>【注意】上述代码与之前用PostSharp的做法是很相似的，不是吗</p>
<p>&nbsp;</p>



<h2>3. 修改ModelBase类型</h2>
<p>Unity默认提供的Intercept，支持两种主要的拦截器：TransparentProxyInterceptor和VirtualMethodInterceptor。我们这里准备用第一种。它有一个简单要求，就是需要拦截的类型，继承<strong><font color="#ff0000">MarshalByRefObject即可</font></strong></p>
<p>代码修改如下</p>
<p>&nbsp;</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.ComponentModel;
<span class="kwrd">using</span> System.Diagnostics;

<span class="kwrd">namespace</span> WPFMVVMSample.Models
{
    <span class="kwrd">public</span> <span class="kwrd">abstract</span> <span class="kwrd">class</span> ModelBase : <strong><font color="#ff0000">MarshalByRefObject</font></strong>, INotifyPropertyChanged
    {

        <span class="kwrd">public</span> <span class="kwrd">event</span> PropertyChangedEventHandler PropertyChanged;

        <span class="kwrd">protected</span> <span class="kwrd">void</span> OnPropertyChanged(<span class="kwrd">string</span> name)
        {
            <span class="kwrd">if</span> (PropertyChanged != <span class="kwrd">null</span>)
                PropertyChanged(<span class="kwrd">this</span>, <span class="kwrd">new</span> PropertyChangedEventArgs(name));

            <span class="rem">//为了便于调试，我们在Output窗口输出一行信息</span>
            Debug.WriteLine(<span class="kwrd">string</span>.Format(<span class="str">"{0} Changed"</span>, name));
        }

    }
}
</pre>
<h2>4.编写代码实现拦截和注入</h2><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Windows;

<span class="kwrd">using</span> Microsoft.Practices.Unity.InterceptionExtension;


<span class="kwrd">namespace</span> WPFMVVMSample
{
    <span class="rem">/// &lt;summary&gt;</span>
    <span class="rem">/// Interaction logic for MainWindow.xaml</span>
    <span class="rem">/// &lt;/summary&gt;</span>
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> MainWindow : Window
    {
        <span class="kwrd">public</span> MainWindow()
        {
            InitializeComponent();

            Loaded += <span class="kwrd">new</span> RoutedEventHandler(MainWindow_Loaded);
        }





        <span class="kwrd">void</span> MainWindow_Loaded(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {

            var order = Intercept.ThroughProxy(<span class="kwrd">new</span> Models.Order(),
                <span class="kwrd">new</span> TransparentProxyInterceptor(),
                <span class="kwrd">new</span>[] { <span class="kwrd">new</span> NotifyPropertyChangedBahavior() });

            order.OrderDate = DateTime.Now;
            order.OrderID = 5;

            
        }
    }
}
</pre><pre class="csharpcode"><font face="Verdana">请注意，这里不能再直接用new的方式创建Order的实例，而是需要通过Intercept来创建。</font></pre><pre class="csharpcode"><font face="Verdana"></font>&nbsp;</pre><pre class="csharpcode"><font face="Verdana">按下F5进行调试，我们同样可以在Output窗口看到有关的消息输出，这说明那个自定义Behavior在起作用，因为是它在调用基类中那个OnPropertyChanged方法</font></pre><pre class="csharpcode"><font face="Verdana"></font>&nbsp;</pre><pre class="csharpcode"><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201106/201106242354543961.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201106/201106242354547026.png" width="695" height="288"></a></pre><pre class="csharpcode">&nbsp;</pre><pre class="csharpcode"><font face="Verdana">值得一提的是,与PostSharp不同，我们这里使用的Interception，是动态拦截，它不会修改我们的代码。请看Order这个类型的代码，与我们在Visual Studio里面是一样的</font></pre><pre class="csharpcode"><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201106/20110624235455647.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201106/201106242354555663.png" width="962" height="740"></a></pre><pre class="csharpcode">&nbsp;</pre><pre class="csharpcode">&nbsp;</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>