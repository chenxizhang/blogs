# Rust初步（五）：Rust与C#性能比较 
> 原文发表于 2015-08-26, 地址: http://www.cnblogs.com/chenxizhang/p/4760172.html 


<p>我学习Rust的目的并不是说期望用它来取代掉现有的开发平台或语言。相反，我认为当前绝大部分研发团队，都不可能只用一个平台或者一个语言。</p> <p>当组织增长，他们越来越依赖大量的编程语言。不同的编程语言有不同的能力和弱点，而一个多语言栈让你在某个特定的编程语言的优点起作用的时候能使用它，当它有缺陷时使用其他编程语言。</p> <p>Rust 主要擅长的领域是：数值计算和线程。</p> <p>我下面用一个实例来比较一下Rust和C#的性能方面表现。这个实例很简单，我们准备开启10个线程，然后在每个线程里面运行一个数值累加的工作任务（500万次。</p> <p>注意，以下测试的耗时，可能在各位的电脑上面会因为配置的不同而不同。我的配置如下</p> <p><a href="http://images0.cnblogs.com/blog/9072/201508/261344532032800.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261344554063673.png" width="1055" height="689"></a></p> <h1>Rust的程序</h1><pre class="csharpcode"><span class="kwrd">extern</span> crate time;

use std::thread;
use time::*;

fn main(){


    let start = time::now();<span class="rem">//获取开始时间</span>

    let handles :Vec&lt;_&gt; =(0..10).map(|_|{
        thread::spawn(||{
            let mut x= 0;
            <span class="kwrd">for</span> _ <span class="kwrd">in</span> (0..5_000_000){
                x+=1
            }
            x
        })
    }).collect();
    <span class="kwrd">for</span> h <span class="kwrd">in</span> handles{
        println!(<span class="str">"Thread finished with count={}"</span>,h.join().map_err(|_| <span class="str">"Could not join a thread!"</span>).unwrap());
    }

    let end = time::now();<span class="rem">//获取结束时间</span>
    let duration = end - start;

    println!(<span class="str">"耗时:{}"</span>,duration);
}
</pre>
<p>&nbsp;</p>
<p>需要注意的是，为了做耗时统计，我们采用了time这个crate，如果有不清楚，请参考我之前的文章：
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<h4><a href="http://www.cnblogs.com/chenxizhang/p/4760087.html">Rust初步（四）：在rust中处理时间</a></h4>
<p>&nbsp;</p>
<p>这个程序，在debug模式下运行的耗时大约是 0.55秒</p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/261344568758687.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261344592653319.png" width="557" height="227"></a></p>
<p>在release模式下运行的耗时大约是 0.002秒</p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/261345116877214.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261345295477271.png" width="612" height="226"></a></p>
<p>&nbsp;</p>
<h1>C#的程序：</h1><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Threading.Tasks;
<span class="kwrd">using</span> System.Diagnostics;
<span class="kwrd">using</span> System.Threading;


<span class="kwrd">namespace</span> ConsoleApplication1
{
    <span class="kwrd">class</span> Program
    {
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {

            Stopwatch watch = <span class="kwrd">new</span> Stopwatch();
            watch.Start();

            Parallel.For(0, 10, i =&gt;
            {
                var x = 0;
                <span class="kwrd">for</span> (<span class="kwrd">int</span> j = 0;  j&lt; 5000000; j++)
                {
                    x += 1;
                }
                Console.WriteLine(<span class="str">"线程:{0} 完成计数"</span>,Thread.CurrentThread.ManagedThreadId);
            });


            watch.Stop();
            Console.WriteLine(<span class="str">"耗时:{0}秒"</span>, watch.Elapsed.TotalSeconds);
            Console.Read();
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>&nbsp;</p>
<p>在Debug模式下面运行的耗时约为0.06秒</p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/261345494537984.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261345584226992.png" width="681" height="446"></a></p>
<p>在Release模式下运行的耗时约为0.012秒</p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/261346047654597.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261346099227972.png" width="681" height="446"></a></p>
<p>&nbsp;</p>
<p>汇总下来比较的结果如下</p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/261346172035262.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261346184843221.png" width="596" height="137"></a></p>
<p>应该说C#新版本中对多线程管理是有了很大的提升的（包括语法很简化）。在Release模式下还是比较慢，是因为Rust是没有运行时的，而C#是要经过CLR运行的。</p>
<p>不过，在Debug模式下，居然C#大幅度胜出了，我感到很意外。从数值上来说，只能说Rust在Debug模式下很慢（可能做了很多事情？）</p></td></tr>