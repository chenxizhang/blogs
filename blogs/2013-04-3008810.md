# 一个distinct问题引发的思考 
> 原文发表于 2013-04-08, 地址: http://www.cnblogs.com/chenxizhang/archive/2013/04/08/3008810.html 


<p>今天被人问到这样一个问题，整理出来给大家也参考一下</p> <p>假设有如下这样一张表格：</p> <p><a href="http://images.cnitblog.com/blog/9072/201304/08203926-02fc0fd92bbe45fb97a7adf7d478dcd1.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201304/08203926-47cc2bdaf31e430f9fe1c3b63073b2e9.png" width="419" height="241"></a></p> <p>这里的数据，具有如下的特征：<font color="#000000"><strong>在一个DepartmentId中，可能会有多个Name，反之也是一样。就是说Name和DepartmentId是多对多的关系</strong></font>。</p> <p>&nbsp;</p> <p>现在想实现这样一个查询：<strong><font color="#ff0000">按照DepartmentID排完序之后（第一步），再获取Name列的不重复值（第二步），而且要保留在第一步后的相对顺序</font></strong>。以本例而言，<font color="#ff0000"><strong>应该返回三个值依次是：ACB</strong></font></p> <p>&nbsp;</p> <p>&nbsp;</p> <p>我们首先会想到下面这样一个写法</p><pre class="csharpcode"><span class="kwrd">select</span> <span class="kwrd">distinct</span> name <span class="kwrd">from</span> Sample <span class="kwrd">order</span> <span class="kwrd">by</span> DepartmentId</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>从语义上说，这是很自然的。但是很可惜，这个语句根本无法执行，错误消息是：</p>
<p><a href="http://images.cnitblog.com/blog/9072/201304/08203927-b88b3b8bbb4b476c93aaa5e6a0275981.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201304/08203927-1866f10c3c2642a09a8c168d53653b30.png" width="696" height="108"></a></p>
<p>这个错误的意思是，如果使用了DISTINCT(去重复值），则出现在OrderBy后面的字段，必须也出现在SELECT后面，但如果DepartmentID如果也真的出现在SELECT后面，显然是不会有重复值的，所以结果肯定也是不对的。</p><pre class="csharpcode"><span class="kwrd">select</span> <span class="kwrd">distinct</span> name,DepartmentId <span class="kwrd">from</span> Sample <span class="kwrd">order</span> <span class="kwrd">by</span> DepartmentId</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p><a href="http://images.cnitblog.com/blog/9072/201304/08203928-b18624a4935c4a8886abab13eba69827.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201304/08203928-e7f36ce0c7e64772b0666d00857f4f96.png" width="311" height="248"></a></p>
<p>&nbsp;</p>
<p>那么，既然DISINCT 与OrderBy结合起来用会有这个的一个问题，我们是否有可能变通一下，例如下面这样：</p><pre class="csharpcode"><span class="kwrd">SELECT</span> <span class="kwrd">distinct</span> a.Name
<span class="kwrd">FROM</span> (<span class="kwrd">select</span> <span class="kwrd">top</span> 100 <span class="kwrd">percent</span> name <span class="kwrd">from</span> Sample <span class="kwrd">order</span> <span class="kwrd">by</span> DepartmentId) a
</pre>
<p>想比较之前的写法，我们用到了子查询技术。同样从语义上看，仍热是很直观明了的。我想先按照DepartmentId进行排序, 然后再去重复值。但是返回到结果是下面这样的：</p>
<p><a href="http://images.cnitblog.com/blog/9072/201304/08203928-3c021395bb2f4851bb5f087a741553d5.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201304/08203929-28f283f302954accbd03c271483e1fa3.png" width="286" height="179"></a></p>
<p>虽然确实去除了重复值，但返回的顺序却是不对的。我们希望是先按照DepartmentId排序之后，然后去除重复值，并且保留排序后的相对顺序。</p>
<p>为什么会出现上面这个结果呢？其实是因为DISTINCT本身是会做排序的，而且这个行为是无法更改的（下图的执行计划中可以看到这一点）。所以其实我们之前做的Order by在这里会失去意义。【实际上，如果观察ADO.NET Entity Framework等ORM工具中生成的类似的一个查询，它会自动丢弃Order by的设置】</p>
<p><a href="http://images.cnitblog.com/blog/9072/201304/08203929-8d4c521cca3f4240be0d59ca80f54c85.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201304/08203929-3199d4bdb109405cb1e1757decec31fd.png" width="1055" height="295"></a></p>
<p>&nbsp;</p>
<p>那么，这样的情况下，是不是就不可能实现需求了呢？虽然说，这个需求并不多见，绝大部分时候，DISTINCT作为最后一个操作，做一次排序是合乎情理的。</p>
<p>我是这样考虑到，既然DISTINCT的这个行为是内置的，那么是否可以绕过这个操作呢？最终我用的一个解决方案是：我能不能把每个Name都编上一个编号，例如有两个A的话，第一个A我为它编号为1，第二个编号为2，以此类推。然后，查询的时候，我先排序，然后筛选那些编号为1的Name，这样其实也就实现了去重复值了。</p>
<p>SQL Server 2005开始提供了一个<a href="http://msdn.microsoft.com/en-us/library/ms186734.aspx" target="_blank">ROW_NUMBER</a>的功能，结合这个功能，我实现了下面这样的查询：</p><pre class="csharpcode"><span class="kwrd">select</span> a.Name  <span class="kwrd">from</span> 
(<span class="kwrd">select</span> <span class="kwrd">top</span> 100 <span class="kwrd">percent</span>
Name,DepartmentId,ROW_NUMBER() <span class="kwrd">over</span>(partition <span class="kwrd">by</span> name <span class="kwrd">order</span> <span class="kwrd">by</span> departmentid) <span class="kwrd">row</span>
<span class="kwrd">from</span> Sample <span class="kwrd">order</span> <span class="kwrd">by</span> DepartmentId) a
<span class="kwrd">where</span> a.<span class="kwrd">row</span>=1
<span class="kwrd">order</span> <span class="kwrd">by</span> a.DepartmentId
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>然后，我得到了下面这样的结果，我推敲下来，这应该是符合了之前提到的这个需求的</p>
<p><a href="http://images.cnitblog.com/blog/9072/201304/08203930-d8b2b3c5070d492496510a4af8263c4a.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201304/08203930-9ef21f1afcdd414c9f0419771ce2f69a.png" width="371" height="179"></a></p>
<p>相比较而言，这个查询的效率会低一些，这个是可以预见的（可以通过下图看出一点端倪）。但如果需求是硬性的，那么牺牲一些性能也是不奇怪的。当然，我们可以再研究看看是否有更优的一些写法。无论如何，使用内置标准的实现，通常都是相对较快的。</p>
<p><a href="http://images.cnitblog.com/blog/9072/201304/08203931-5b22f523e4c2449298922c13a36a3f53.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201304/08203932-560fa6651ade464c8f8352b5ae4863a5.png" width="1255" height="423"></a></p>