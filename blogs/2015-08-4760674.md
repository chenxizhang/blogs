# Rust初步（六）：在C#中使用Rust组件 
> 原文发表于 2015-08-26, 地址: http://www.cnblogs.com/chenxizhang/p/4760674.html 


<p><a href="http://www.cnblogs.com/chenxizhang/p/4760172.html">上一篇</a>文章，我们通过实例比较了一下C#和Rust的性能表现，应该说在Release模式下面，Rust进行计算密集型的运算还是有些比较明显的优势的。那么，我们有没有可能，在C#中做一些快速应用开发，而一些核心的算法用Rust来实现呢？答案是可以的。</p> <p>&nbsp;</p> <h1>编写Rust代码</h1> <p>下面这段代码，保存在lib.rs文件中</p><pre class="csharpcode">use std::thread;

#[no_mangle]
pub <span class="kwrd">extern</span> fn process(){
    let handles :Vec&lt;_&gt; =(0..10).map(|_|{
        thread::spawn(||{
            let mut x= 0;
            <span class="kwrd">for</span> _ <span class="kwrd">in</span> (0..5_000_000){
                x+=1
            }
            x
        })
    }).collect();


    <span class="kwrd">for</span> h <span class="kwrd">in</span> handles{
        println!(<span class="str">"Thread finished with count={}"</span>,h.join().map_err(|_| <span class="str">"Could not join a thread!"</span>).unwrap());
    }

    println!(<span class="str">"done!"</span>);
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>&nbsp;</p>
<p>这段代码的几个关键点在于</p>
<p>1.声明为pub，也就是说要让外部可以访问到</p>
<p>2.声明为extern，意思应该也是说希望外部可以访问</p>
<p>3.添加一个标记 #[no_mangle]，这个开关据说是阻止编译器在编译的时候，重命名函数。我也还不是很理解，先照这么做吧</p>
<p>&nbsp;</p>
<p>其他部分就是标准的Rust代码了</p>
<p>&nbsp;</p>
<h1>生成Rust的动态链接库</h1>
<p>默认情况下，Rust编译的库叫做静态链接库，如果我们需要编译动态链接库的话，需要在Cargo.toml文件中定义</p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/261556059533769.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261556064693328.png" width="586" height="354"></a></p>
<p>然后，运行cargo build -- release命令生成动态链接库（dll）</p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/261556070003955.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261556104069529.png" width="897" height="144"></a></p>
<p>我们在输出目录中，可以看到一个countlib.dll 的动态链接库文件</p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/261556108593602.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261556117195731.png" width="729" height="355"></a></p>
<p>&nbsp;</p>
<h1>在C#中使用这个动态链接库</h1>
<p>你可以将countlib.dll放在C#编译输出目录的根目录下面</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Threading.Tasks;
<span class="kwrd">using</span> System.Diagnostics;
<span class="kwrd">using</span> System.Threading;
<span class="kwrd">using</span> System.Runtime.InteropServices;


<span class="kwrd">namespace</span> ConsoleApplication1
{
    <span class="kwrd">class</span> Program
    {

        <strong><font color="#ff0000">[DllImport(<span class="str">"countlib.dll"</span>,CallingConvention= CallingConvention.Cdecl)]
        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">extern</span> <span class="kwrd">void</span> process();</font></strong>

        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            Stopwatch watch = <span class="kwrd">new</span> Stopwatch();
            watch.Start();

            <span class="rem">//Parallel.For(0, 10, i =&gt;</span>
            <span class="rem">//{</span>
            <span class="rem">//    var x = 0;</span>
            <span class="rem">//    for (int j = 0;  j&lt; 5000000; j++)</span>
            <span class="rem">//    {</span>
            <span class="rem">//        x += 1;</span>
            <span class="rem">//    }</span>
            <span class="rem">//    Console.WriteLine("线程:{0} 完成计数",Thread.CurrentThread.ManagedThreadId);</span>
            <span class="rem">//});</span>

            <strong><font color="#ff0000">process();<span class="rem">//调用Rust里面的程序process进行计算</span></font></strong>

            watch.Stop();
            Console.WriteLine(<span class="str">"耗时:{0}秒"</span>, watch.Elapsed.TotalSeconds);
            Console.Read();
        }
    }

}
</pre><pre class="csharpcode">&nbsp;</pre><pre class="csharpcode">在Debug模式下面的耗时为 0.002秒（提升太明显了吧）</pre><pre class="csharpcode"><a href="http://images0.cnblogs.com/blog/9072/201508/261556127347674.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261556136253346.png" width="681" height="281"></a></pre><pre class="csharpcode">&nbsp;</pre><pre class="csharpcode">在Release模式下面的耗时为0.002秒（基本上跟Debug模式不相上下，很神奇吗）</pre><pre class="csharpcode"><a href="http://images0.cnblogs.com/blog/9072/201508/261556146875005.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261556155477134.png" width="681" height="265"></a></pre><pre class="csharpcode">&nbsp;</pre><pre class="csharpcode">那么，这个性能表现，几乎接近了直接使用Rust的性能，比原先用C#的方式提高了5倍。</pre><pre class="csharpcode">&nbsp;</pre><pre class="csharpcode">如此说来，计算密集型（尤其是需要用到多线程，多核）的任务，可以用Rust来编写，然后在C#中调用。</pre><pre class="csharpcode">&nbsp;</pre><pre class="csharpcode"><font color="#ff0000">【特别注意】</font></pre><pre class="csharpcode">cargo build默认情况下会根据当前计算机的配置进行编译，例如我是64位的计算机，那么编译出来的dll也是64位的，在C#中用的时候，就需要同样设置为64位，否则就会出现错误</pre><pre class="csharpcode"><a href="http://images0.cnblogs.com/blog/9072/201508/261556181254121.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261556199069165.png" width="244" height="130"></a></pre><pre class="csharpcode">&nbsp;</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>



<p>那么，cargo build是否可以指定对应的平台进行编译呢？可以通过指定 --target参数来实现，可用的值主要有</p><pre><code>x86_64-pc-windows-gnu</code></pre><pre><code>i686-unknown-linux-gnu</code></pre><pre><code>x86_64-unknown-linux-gnu</code></pre><pre><code>详细可以参考 <a title="http://doc.crates.io/manifest.html" href="http://doc.crates.io/manifest.html">http://doc.crates.io/manifest.html</a></code></pre><pre><code>我用下面这样用就可以编译一个通用的dll（既能用于32位，也能用于64位——采用WOW模式）</code></pre><pre><a href="http://images0.cnblogs.com/blog/9072/201508/261556203901481.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261556211094866.png" width="770" height="107"></a></pre><pre>&nbsp;</pre><pre>其实这个编译选项，类似于我们在Visual Studio中使用Any CPU进行编译</pre><pre><a href="http://images0.cnblogs.com/blog/9072/201508/261556247503511.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/261556253757869.png" width="851" height="368"></a></pre>