# 如何在记录异常日志的时候包含源代码文件名和行号等信息 
> 原文发表于 2013-07-12, 地址: http://www.cnblogs.com/chenxizhang/p/3185702.html 


<h1>前言</h1> <p>作为一个程序员，你的相当一部分时间可能会用在调试。不知道大家是否同意，异常处理(Exception Handling)是一个看似简单，但是又极难做好的工作。当然，现在已经有一些业界经验以及框架（例如Enterprise Library中的Exception Handling Application Block）可供参考和使用，这些框架可以帮助我们较为灵活地配置，处理或者记录异常。我今天要跟大家分享的一个话题是，如何在记录异常的时候，包含源代码文件名和行号等有用信息。如果有这些信息，我们将能更加简单地定位到问题所在。</p> <p>&nbsp;</p> <h1>案例演示</h1> <p>为了讲解这个内容，我准备了一个简单的项目来做演示，如下所示</p> <p><a href="http://images.cnitblog.com/blog/9072/201307/12101207-ce199f4c847c4af18ceeceeb124c6cae.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101208-29e7dbf1f9144a00a2b61fe183613ac3.png" width="244" height="153"></a></p> <p>实际上，这个Solution中有两个项目，一个是作为组件的ClassLibrarySample</p> <div class="csharpcode"><pre><span class="lnum">   1:  </span><span class="kwrd">using</span> System;</pre><pre><span class="lnum">   2:  </span>&nbsp;</pre><pre><span class="lnum">   3:  </span><span class="kwrd">namespace</span> ClassLibrarySample</pre><pre><span class="lnum">   4:  </span>{</pre><pre><span class="lnum">   5:  </span>    <span class="kwrd">public</span> <span class="kwrd">class</span> Test</pre><pre><span class="lnum">   6:  </span>    {</pre><pre><span class="lnum">   7:  </span>        <span class="kwrd">public</span> <span class="kwrd">void</span> MyMethod(<span class="kwrd">int</span> a, <span class="kwrd">int</span> b) {</pre><pre><span class="lnum">   8:  </span>            <span class="kwrd">try</span></pre><pre><span class="lnum">   9:  </span>            {</pre><pre><span class="lnum">  10:  </span>                Console.WriteLine(b/a);</pre><pre><span class="lnum">  11:  </span>            }</pre><pre><span class="lnum">  12:  </span>            <span class="kwrd">catch</span> (Exception ex)</pre><pre><span class="lnum">  13:  </span>            {</pre><pre><span class="lnum">  14:  </span>                Console.WriteLine(ex.Message);</pre><pre><span class="lnum">  15:  </span>            }</pre><pre><span class="lnum">  16:  </span>        }</pre><pre><span class="lnum">  17:  </span>    }</pre><pre><span class="lnum">  18:  </span>}</pre></div>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
<pre class="csharpcode">&nbsp;</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>&nbsp;</p>
<p>另一个是作为调用程序的ConsoleApplicationSample</p>
<div class="csharpcode"><pre><span class="lnum">   1:  </span><span class="kwrd">using</span> System;</pre><pre><span class="lnum">   2:  </span>&nbsp;</pre><pre><span class="lnum">   3:  </span><span class="kwrd">namespace</span> ConsoleApplicationSample</pre><pre><span class="lnum">   4:  </span>{</pre><pre><span class="lnum">   5:  </span>    <span class="kwrd">class</span> Program</pre><pre><span class="lnum">   6:  </span>    {</pre><pre><span class="lnum">   7:  </span>        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)</pre><pre><span class="lnum">   8:  </span>        {</pre><pre><span class="lnum">   9:  </span>            var t = <span class="kwrd">new</span> ClassLibrarySample.Test();</pre><pre><span class="lnum">  10:  </span>            t.MyMethod(0, 1);<span class="rem">//这个调用会出错，因为会发生除零错误</span></pre><pre><span class="lnum">  11:  </span>            Console.Read();</pre><pre><span class="lnum">  12:  </span>        }</pre><pre><span class="lnum">  13:  </span>    }</pre><pre><span class="lnum">  14:  </span>}</pre></div>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>这个程序运行起来肯定就是会报告异常，然后被捕捉到，我们在主程序上面可以看到如下的输出</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101208-67399773ad3c4faaa08ca4ca6680d2d0.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101209-5df4516cafc14dc082fb6c1ee9c04232.png" width="244" height="43"></a></p>
<p>我们都知道，这样的异常消息可能对我们帮助不是很大，尤其是如果源文件中代码有成百上千行，那么如果不能快速定位到可能是哪一行出了这个异常，那么看起来调试和排错都会很难。</p>
<p>那么是否有办法在异常消息中，得到源代码文件的一些信息呢？事实上是可以做到的，你只要像下面这样修改即可：使用了<a href="http://msdn.microsoft.com/zh-cn/library/vstudio/system.diagnostics.stacktrace.aspx">StackTrace</a>这个类型</p>
<div class="csharpcode"><pre><span class="lnum">   1:  </span><span class="kwrd">using</span> System;</pre><pre><span class="lnum">   2:  </span><span class="kwrd">using</span> System.Diagnostics;</pre><pre><span class="lnum">   3:  </span>&nbsp;</pre><pre><span class="lnum">   4:  </span><span class="kwrd">namespace</span> ClassLibrarySample</pre><pre><span class="lnum">   5:  </span>{</pre><pre><span class="lnum">   6:  </span>    <span class="kwrd">public</span> <span class="kwrd">class</span> Test</pre><pre><span class="lnum">   7:  </span>    {</pre><pre><span class="lnum">   8:  </span>        <span class="kwrd">public</span> <span class="kwrd">void</span> MyMethod(<span class="kwrd">int</span> a, <span class="kwrd">int</span> b) {</pre><pre><span class="lnum">   9:  </span>            <span class="kwrd">try</span></pre><pre><span class="lnum">  10:  </span>            {</pre><pre><span class="lnum">  11:  </span>                Console.WriteLine(b/a);</pre><pre><span class="lnum">  12:  </span>            }</pre><pre><span class="lnum">  13:  </span>            <span class="kwrd">catch</span> (Exception ex)</pre><pre><span class="lnum">  14:  </span>            {</pre><pre><span class="lnum">  15:  </span>                Console.WriteLine(ex.Message);</pre><pre><span class="lnum">  16:  </span>                <span class="rem">//通过如下代码来记录异常详细的信息</span></pre><pre><span class="lnum">  17:  </span>                var trace = <span class="kwrd">new</span> StackTrace(ex, <span class="kwrd">true</span>).GetFrame(0);</pre><pre><span class="lnum">  18:  </span>                Console.WriteLine(<span class="str">"文件名:{0},行号:{1},列号:{2}"</span>, trace.GetFileName(), trace.GetFileLineNumber(), trace.GetFileColumnNumber());</pre><pre><span class="lnum">  19:  </span>            }</pre><pre><span class="lnum">  20:  </span>        }</pre><pre><span class="lnum">  21:  </span>    }</pre><pre><span class="lnum">  22:  </span>}</pre></div>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>这样一来，我们再进行调试的时候，就可以看到更加详细的信息了。</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101209-a5aa538c1d07433b9738aa48d55e1c5d.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101209-ddf7c7d3771c4328bb020c7e6ed6049c.png" width="244" height="82"></a></p>
<p>大家可能会很好奇，这个信息是怎么给我们的呢？其实，要想实现这个功能，必须满足一个前提条件，就是必须有ClassLibrarySample这个组件对应的调试符号文件(pdb)。</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101210-bdbf8ecbec9b404e8539384fc472e901.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101211-ef6f0bb931c342c39cba894d7c44664e.png" width="244" height="72"></a></p>
<p>如果我将这个文件删除掉，会怎么样呢？</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101211-08760fdfe9cf4186a0f1c3775978c93f.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101212-5b9dd3edf7f64774b164dc6ed9181e7d.png" width="244" height="82"></a></p>
<p>我们看到，如果没有pdb文件，则输出的信息是空白的。<br></p>
<p>所以，<strong><font color="#ff0000">如果你想使用这个技术来记录这些与源代码有关的详细信息，需要确保在部署应用程序的时候，将有关组件的pdb文件也一起部署</font></strong>。</p>
<p>如果是私有部署的话，那么要做到这一点是不难的，打包的时候，将pdb文件一起包含进去就可以了。但如果这个组件是公有部署（部署到GAC) 的话，就需要额外的一些步骤。</p>
<p>为了将程序集部署到GAC，我们首先需要对其进行强名称签名。</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101212-b7d2ebcc9fc447bbbcb34873b56a45bc.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101212-b71588cbe45946fd8f235edd238d5a2c.png" width="244" height="142"></a></p>
<p>然后，通过gacutil这个命令行工具，可以手工地将其添加到GAC中</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101214-f55b501748fe41b398118c883c9231f0.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101215-6919035b98c944e0a112e53a3ce93369.png" width="244" height="77"></a></p>
<p>接下来，为了让主程序使用GAC中这个组件，而不是程序根目录下面的那个。我们需要对引用做一个设置：Copy local设置为false</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101215-a96efbd97eef47899d774950564e629b.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101216-3f554c55d8e14ebabed3744463d50a4f.png" width="231" height="244"></a></p>
<p>再次运行主程序的话，我们会得到如下的输出</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101216-b8211a6d843c4d3eac02908700a87e96.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101216-96886d5cb6a64358b5a0e54425785ce6.png" width="244" height="82"></a></p>
<p>还是没有与源代码有关的详细信息，这是因为注册到GAC的程序集默认都是没有pdb文件的。他们一般在下面这样的目录里面</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101216-520f9b9d23ba4da9a8000d6153973a72.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101217-bb5cb1474c2848e684a3d5b3d02c0442.png" width="244" height="50"></a></p>
<p>【备注】.NET Framework 4.0这个版本中对于GAC的路径做了调整，不再是原先的c:\windows\assembly目录了</p>
<p>所以，如果需要的话，你可以将pdb文件，手工（或者通过脚本）复制到这个目录，例如</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101217-0cf877e661ae4d02bbc33aeebbb87c54.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101217-7d9ebf7ce01041ddb0b3b2d8b68c6994.png" width="244" height="58"></a></p>
<p>这样的话，就可以在运行主程序的时候，得到与源代码有关的详细信息了。</p>
<p><a href="http://images.cnitblog.com/blog/9072/201307/12101217-c4dcdc9ab6704238b76974ac1e5b347d.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201307/12101217-11cba03c01764bd89463fcca95d36763.png" width="244" height="161"></a></p>