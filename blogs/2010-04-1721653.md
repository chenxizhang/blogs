# MOSS 2010:Visual Studio 2010开发体验（16）&mdash;&mdash;客户端对象模型 
> 原文发表于 2010-04-26, 地址: http://www.cnblogs.com/chenxizhang/archive/2010/04/26/1721653.html 


<p><a href="http://www.cnblogs.com/chenxizhang/archive/2010/04/26/1721573.html">上一篇</a>，我们讲到了LINQ to SharePoint。它提供了很自然的语法，提高了开发体验。但归根结底，LINQ to SharePoint是使用了服务器对象模型，也就是说，通过这样方式编写的代码，必须在服务器运行。大家其实也发现了，我们并没有在任何地方指定过用户的身份。这意味着什么呢？那种方式就默认使用当前用户的凭据作为身份验证。</p> <p>但是，假设我们的应用程序并不在服务器，而是在客户端运行的话，那么该怎么办呢？</p> <p>以前（MOSS 2007或者WSS 3.0中），我们是通过一些Web Service的方式来实现的。这里有一个链接可以供参考</p> <p><a href="http://msdn.microsoft.com/en-us/library/ms479390.aspx">http://msdn.microsoft.com/en-us/library/ms479390.aspx</a></p> <p>实际上，他们是在下面的这个目录中的一些asmx文件</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/MOSS2010VisualStudio201016_14CB1/image_2.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/MOSS2010VisualStudio201016_14CB1/image_thumb.png" width="792" height="581"></a> </p> <p>但实际上，我们用起来并不是很方便，为了尽可能通用，所以它返回来的数据是用XML方式包装的，解析起来很费劲，我这里找了一段之前写过的代码</p><pre class="csharpcode">
            localhost.Lists proxy = <span class="kwrd">new</span> localhost.Lists();
            proxy.UseDefaultCredentials = <span class="kwrd">true</span>;<span class="rem">//使用当前用户的凭据</span>

            XmlDocument doc = <span class="kwrd">new</span> XmlDocument();
            XmlNode q = doc.CreateElement(<span class="str">"Query"</span>);
            q.InnerXml = <span class="str">"&lt;Where&gt;&lt;Eq&gt;&lt;FieldRef Name=\"Status\" /&gt;&lt;Value Type=\"Text\"&gt;未启动&lt;/Value&gt;&lt;/Eq&gt;&lt;/Where&gt;"</span>;

            XmlNode f = doc.CreateElement(<span class="str">"ViewFields"</span>);
            f.InnerXml = GetViewFieldsSettings(<span class="str">"标题,说明"</span>, list);

            XmlNode o = doc.CreateElement(<span class="str">"QueryOptions"</span>);

            XmlNode items = proxy.GetListItems(<span class="str">"任务"</span>, <span class="str">""</span>, q, f, <span class="str">""</span>, o, web.ID.ToString());
            XmlNamespaceManager xnm = <span class="kwrd">new</span> XmlNamespaceManager(items.OwnerDocument.NameTable);
            xnm.AddNamespace(<span class="str">"rs"</span>, <span class="str">"urn:schemas-microsoft-com:rowset"</span>);
            xnm.AddNamespace(<span class="str">"z"</span>, <span class="str">"#RowsetSchema"</span>);
            XmlNode resultcount = items.SelectSingleNode(<span class="str">"rs:data"</span>, xnm);
            Console.WriteLine(<span class="str">"总记录数:{0}"</span>, resultcount.Attributes[<span class="str">"ItemCount"</span>].Value);

            XmlNodeList result = items.SelectNodes(<span class="str">"//z:row"</span>, xnm);
            <span class="kwrd">int</span> index = 0;

            <span class="kwrd">foreach</span> (XmlNode item <span class="kwrd">in</span> result)
            {
                Console.WriteLine(<span class="str">"第{0}行记录"</span>, ++index);
                <span class="kwrd">foreach</span> (XmlAttribute att <span class="kwrd">in</span> item.Attributes)
                {
                    Console.WriteLine(<span class="str">"\t{0}:{1}"</span>, att.Name, att.Value);
                }
                Console.WriteLine();
            }
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>&nbsp;</p>
<p>这里首先我们还是需要用到CAML语法定义查询，但最要命的是它返回的结果是XMLNode，我们还要通过XML的解析方式去处理它。这次第，怎一个苦字了得？<a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/MOSS2010VisualStudio201016_14CB1/%E5%AF%92_2.gif" class="thickbox"><img title="寒" border="0" alt="寒" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/MOSS2010VisualStudio201016_14CB1/%E5%AF%92_thumb.gif" width="42" height="42"></a> </p>
<p>为什么这么苦？为什么这么累？归根结底就是因为之前版本的SharePoint并没有提供可供客户端使用的对象模型。</p>
<p>&nbsp;</p>
<p>现在我们就可以摆脱这种痛苦的境地了，因为MOSS 2010提供了全新的客户端对象模型。该模型既可用于.NET程序，又可用于javascript。换而言之，任何客户端都可以有机会来访问到SharePoint 的数据。</p>
<p>这一篇先讲解一下在.NET客户端应用程序中使用对象模型查询列表数据。</p>
<p>&nbsp;</p>
<p>第一步，添加引用。MOSS 2010提供了两个特殊的dll，可以供客户端应用程序引用</p>
<p>他们一般是在C:\Program Files\Common Files\Microsoft Shared\Web Server Extensions\14\ISAPI这个目录</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/MOSS2010VisualStudio201016_14CB1/image_4.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/MOSS2010VisualStudio201016_14CB1/image_thumb_1.png" width="1044" height="810"></a> </p>
<p>第二步，编写如下代码来完成列表查询</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="kwrd">using</span> Microsoft.SharePoint.Client;


<span class="kwrd">namespace</span> ConsoleApplication1
{
    <span class="kwrd">class</span> Program
    {
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            var url = <span class="str">"http://localhost:45223/sites/dev"</span>;

            <span class="kwrd">using</span> (ClientContext ctx = <span class="kwrd">new</span> ClientContext(url))
            {
                ctx.Credentials = System.Net.CredentialCache.DefaultNetworkCredentials;
                Web web = ctx.Web;
                ctx.Load(web);
                ctx.Load(web.Lists);
                ctx.Load(web, w =&gt; w.Lists.Where(l =&gt; l.Title == <span class="str">"Employees"</span>));
                ctx.ExecuteQuery();

                List list = web.Lists[0];
                CamlQuery camlQuery = <span class="kwrd">new</span> CamlQuery();
                camlQuery.ViewXml = <span class="str">"&lt;View&gt;&lt;Query&gt;&lt;Where&gt;&lt;Lt&gt;&lt;FieldRef Name='Age' /&gt;&lt;Value Type='Number'&gt;60&lt;/Value&gt;&lt;/Lt&gt;&lt;/Where&gt;&lt;/Query&gt;&lt;RowLimit&gt;100&lt;/RowLimit&gt;&lt;/View&gt;"</span>;

                ListItemCollection collListItem = list.GetItems(camlQuery);

                ctx.Load(collListItem);
                ctx.ExecuteQuery();

                <span class="kwrd">foreach</span> (var item <span class="kwrd">in</span> collListItem)
                {
                    Console.WriteLine(<span class="str">"FullName:{0},{1} Age:{2}"</span>,
                        item[<span class="str">"FirstName"</span>],
                        item[<span class="str">"LastName"</span>],
                        item[<span class="str">"Age"</span>]);
                }
            }

            Console.Read();
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>【注意】这里的CamlQuery的定义有些特殊，它最外层是一个View元素，里面有一个Query元素。</p>
<p>【注意】ClientContext这个对象是有一个属性叫Credentials的，换而言之，我们可以在客户端传递有关的身份过来</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/MOSS2010VisualStudio201016_14CB1/image_6.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/MOSS2010VisualStudio201016_14CB1/image_thumb_2.png" width="1044" height="810"></a> </p>
<p>通过这个简单的例子，大家了解了如何通过客户端对象模型访问到SharePont站点中的列表。（其实远远不限于列表访问）</p>
<p>如果和之前Web Service的方式进行比较的话，一个最明显的好处就是返回值是强类型的，而不是一段XML了。这既有好处，也有坏处。好处就是.NET程序处理比较方便，坏处就是其他平台可能就无法使用这些结果。那么如何让其他平台，或者简单地说，我们如何在javascript中访问这些数据呢？请期待下一篇的介绍</p>
<p>后面我们还将介绍在Silverlight中使用客户端模型的做法，那是不太一样的。Silverlight的所有数据访问操作都是异步的，具体的内容，请听下回分解吧</p>