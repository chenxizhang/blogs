# 再谈CLR：构造之谜 
> 原文发表于 2010-03-21, 地址: http://www.cnblogs.com/chenxizhang/archive/2010/03/21/1691105.html 


<p>这一篇谈谈类型构造的问题。主要针对构造器这个层面进行一些探讨。</p> <p>1. 有哪几种构造器</p> <ul> <li>默认构造器（无参数）  <li>自定义构造器（有参数）  <li>静态构造器</li></ul> <p>2.何时调用构造器</p> <ul> <li>通过new关键字创建实例的时候  <li>通过createInstance方法创建实例的时候  <li>静态构造器是不能调用的，是由CLR调用，而且它只被调用一次（Assembly级别）</li></ul> <p>3. 特殊问题</p> <ul> <li>默认构造器默认有一个实现，当然没有任何代码</li></ul> <p><a class="thickbox" href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/CLR_5E34/image_2.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/CLR_5E34/image_thumb.png" width="644" height="404"></a> </p> <ul> <li>如果我们编写了自定义构造器，此时默认构造器就不会自动产生一个，除非显式定义。（这个行为有点怪异）</li></ul><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;
<span class="kwrd">using</span> System.Reflection;
<span class="kwrd">using</span> System.Threading;

<span class="kwrd">namespace</span> ConsoleApplication1
{
    <span class="kwrd">class</span> Program
    {
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {

            Console.Title = <span class="str">"构造之谜"</span>;

            <span class="rem">//1.通过new的方式进行构造</span>
            Employee emp = <span class="kwrd">new</span> Employee() { FirstName = <span class="str">"ares"</span>, LastName = <span class="str">"chen"</span> };
            Console.WriteLine(emp);

            <span class="rem">//如果没有默认构造器，则编译出错</span>
            Employee emp1 = <span class="kwrd">new</span> Employee(<span class="str">"ares"</span>, <span class="str">"chen"</span>);
            Console.WriteLine(emp1);


            <span class="rem">//2.通过CreateInstance方式进行构造，这是调用默认构造器</span>
            Employee emp2 = Assembly.GetExecutingAssembly().CreateInstance(<span class="kwrd">typeof</span>(Employee).FullName) <span class="kwrd">as</span> Employee;
            <span class="rem">//如果没有默认构造器，则编译不出错，而运行出错，因为CreateInstance方法是调用默认构造器的</span>

            emp2.FirstName = <span class="str">"ares"</span>;
            emp2.LastName = <span class="str">"chen"</span>;
            Console.WriteLine(emp2);

            <span class="rem">//3.通过带参数的CreateInstance方式构造，这是调用自定义构造器</span>
            Employee emp3 = Assembly.GetExecutingAssembly().CreateInstance(
                <span class="kwrd">typeof</span>(Employee).FullName,
                <span class="kwrd">true</span>, BindingFlags.CreateInstance,
                <span class="kwrd">null</span>,
                <span class="kwrd">new</span> <span class="kwrd">object</span>[] { <span class="str">"ares"</span>, <span class="str">"chen"</span> },
                Thread.CurrentThread.CurrentCulture,
                <span class="kwrd">null</span>) <span class="kwrd">as</span> Employee;

            Console.WriteLine(emp3);

            <span class="rem">//4.通过隐式操作符来构造</span>
            Employee emp4 = <span class="str">"ares,chen"</span>;
            Console.WriteLine(emp4);

            Console.Read();
        }
    }

    <span class="kwrd">class</span> Employee {

        <span class="kwrd">static</span> Employee()
        {
            <span class="rem">//静态构造器只会被调用一次，而且永远会被调用</span>
            Console.WriteLine(<span class="str">"静态构造器在工作"</span>);

            <span class="rem">//如果类型的静态成员需要经过复杂的逻辑才能初始化，那么应该在静态构造器里面对其进行处理</span>
        }

        <span class="kwrd">public</span> Employee()
        {
            <span class="rem">//这个构造器默认就是有的，但如果有自定义构造器，则需要显式地定义该构造器</span>
            Console.WriteLine(<span class="str">"默认构造器在工作"</span>);
        }

        <span class="kwrd">public</span> Employee(<span class="kwrd">string</span> firstName, <span class="kwrd">string</span> lastName) {
            <span class="rem">//如果编写了自定义构造器，默认情况下居然会把默认构造器禁用掉。必须显式地定义默认构造器</span>

            FirstName = firstName;
            LastName = lastName;

            Console.WriteLine(<span class="str">"自定义构造器在工作"</span>);
        }
        <span class="kwrd">public</span> <span class="kwrd">string</span> FirstName { get; set; }
        <span class="kwrd">public</span> <span class="kwrd">string</span> LastName { get; set; }

        <span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">string</span> ToString()
        {
            <span class="kwrd">return</span> <span class="kwrd">string</span>.Format(<span class="str">"Employee:{0},{1}"</span>, FirstName, LastName);
        }


        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">implicit</span> <span class="kwrd">operator</span> Employee(<span class="kwrd">string</span> employee) {
            <span class="kwrd">return</span> <span class="kwrd">new</span> Employee()
            {
                FirstName = employee.Split(<span class="str">','</span>)[0],
                LastName = employee.Split(<span class="str">','</span>)[1]
            };
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p><a class="thickbox" href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/CLR_5E34/image_4.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/CLR_5E34/image_thumb_1.png" width="681" height="446"></a></p>