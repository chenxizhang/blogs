# 如何在SSIS的脚本组件中访问变量 
> 原文发表于 2011-05-21, 地址: http://www.cnblogs.com/chenxizhang/archive/2011/05/21/2053055.html 


<p>这是一个小问题，我们在SSIS的设计中很多地方都会用到变量，我习惯性地将“变量”和“表达式”称为SSIS的灵魂，虽然不见得绝对准确，但它们确实是保证一个SSIS包灵活性的根本。</p> <p>同时，我们可能也会在数据流任务中添加“脚本组件”，用我们熟知的C#或者VB.NET编写一些数据转换处理的逻辑。这里可能就有一个需求，我们希望在脚本组件中访问变量（读或者写），但默认情况下，这个需求并不是那么容易实现。我们来看下面的例子</p> <p>&nbsp;</p> <p>这个例子中，我们在Package级别定义了一个变量，名称为test</p> <p><a href="http://www.xizhang.com/blogimages/SSIS_11646/image.png"><img title="image" border="0" alt="image" src="http://www.xizhang.com/blogimages/SSIS_11646/image_thumb.png" width="1042" height="500"></a></p> <p>然后,我们在数据流中有一个Script Component，我们尝试在里面对上面这个变量进行读写</p> <p><a href="http://www.xizhang.com/blogimages/SSIS_11646/image_3.png"><img title="image" border="0" alt="image" src="http://www.xizhang.com/blogimages/SSIS_11646/image_thumb_3.png" width="838" height="528"></a></p> <p>代码大致如下</p><pre class="csharpcode"><span class="rem">/* Microsoft SQL Server Integration Services Script Component</span>
<span class="rem">*  Write scripts using Microsoft Visual C# 2008.</span>
<span class="rem">*  ScriptMain is the entry point class of the script.*/</span>

<span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Data;
<span class="kwrd">using</span> Microsoft.SqlServer.Dts.Pipeline.Wrapper;
<span class="kwrd">using</span> Microsoft.SqlServer.Dts.Runtime.Wrapper;

<span class="kwrd">using</span> System.Windows.Forms;


[Microsoft.SqlServer.Dts.Pipeline.SSISScriptComponentEntryPointAttribute]
<span class="kwrd">public</span> <span class="kwrd">class</span> ScriptMain : UserComponent
{

    <span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">void</span> PreExecute()
    {
        <span class="kwrd">base</span>.PreExecute();
        <span class="rem">/*</span>
<span class="rem">          Add your code here for preprocessing or remove if not needed</span>
<span class="rem">        */</span>
    }

    <span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">void</span> PostExecute()
    {
        <span class="kwrd">base</span>.PostExecute();
        <span class="rem">/*</span>
<span class="rem">          Add your code here for postprocessing or remove if not needed</span>
<span class="rem">          You can set read/write variables here, for example:</span>
<span class="rem">          Variables.MyIntVar = 100</span>
<span class="rem">        */</span>
    }

    <span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">void</span> Input0_ProcessInputRow(Input0Buffer Row)
    {
        <span class="rem">/*</span>
<span class="rem">          Add your code here</span>
<span class="rem">        */</span>


        <strong><font color="#ff0000">MessageBox.Show(Variables.test.ToString());</font></strong>
        
        
        
    }

}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>


<p>&nbsp;</p>
<p>代码很简单，也很自然。我只是作为演示，这里读取到那个变量之后，显示出来。</p>
<p>但是这个代码是不能运行的，有如下错误</p>
<p><a href="http://www.xizhang.com/blogimages/SSIS_11646/image_4.png"><img title="image" border="0" alt="image" src="http://www.xizhang.com/blogimages/SSIS_11646/image_thumb_4.png" width="505" height="367"></a></p>
<p>上述错误的意思是，除非在PostExecute方法里面，是不可以对变量进行读写的。这里的原因是，ProcessInputRow这个方法，因为是每一行数据都会执行一次，所以如果这里随意读写变量的话，会因为要频繁加锁和解锁，造成效率方面的问题。</p>
<p>&nbsp;</p>
<p>这里谈到了一个加锁的问题。为什么会有这个问题呢？其实很简单，因为变量是定义在Package级别，所以很可能几个任务在同时访问这些变量，都在对其进行读写。如果不加锁，则可能导致不可预期的结果。</p>
<p>&nbsp;</p>
<p>如果你理解了上述机制，而且也确定可以承担锁定可能带来的性能损耗，那么要解决问题，可以通过如下的方式实现</p>
<p>&nbsp;</p><pre class="csharpcode">
    <span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">void</span> Input0_ProcessInputRow(Input0Buffer Row)
    {
        <span class="rem">/*</span>
<span class="rem">          Add your code here</span>
<span class="rem">        */</span>

        VariableDispenser.LockForRead(<span class="str">"User::test"</span>);<span class="rem">//这里先声明对某个变量进行锁定</span>

        IDTSVariables100 vs = <span class="kwrd">null</span>;
        <span class="kwrd">this</span>.VariableDispenser.GetVariables(<span class="kwrd">out</span> vs);<span class="rem">//通过VariableDispenser获取变量集合</span>
        MessageBox.Show(vs[<span class="str">"User::test"</span>].Value.ToString());

        vs.Unlock();<span class="rem">//解锁</span>
       
        
        
    }</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>