# .NET 4中并行编程的简单例子 
> 原文发表于 2010-04-16, 地址: http://www.cnblogs.com/chenxizhang/archive/2010/04/16/1713167.html 


<p>该文可参考 <a href="http://msdn.microsoft.com/en-us/library/dd460720(VS.100).aspx">http://msdn.microsoft.com/en-us/library/dd460720(VS.100).aspx</a></p><pre class="csharpcode"><span class="kwrd">namespace</span> ForEachDemo
{
    <span class="kwrd">using</span> System;
    <span class="kwrd">using</span> System.Drawing; <span class="rem">// requires system.Drawing.dll</span>
    <span class="kwrd">using</span> System.IO;
    <span class="kwrd">using</span> System.Threading;
    <span class="kwrd">using</span> System.Threading.Tasks;

    <span class="kwrd">class</span> SimpleForEach
    {
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main()
        {
            <span class="rem">// A simple source for demonstration purposes. Modify this path as necessary.</span>
            <span class="kwrd">string</span>[] files = System.IO.Directory.GetFiles(<span class="str">@"C:\Users\Public\Pictures\Sample Pictures"</span>, <span class="str">"*.jpg"</span>);
            <span class="kwrd">string</span> newDir = <span class="str">@"C:\Users\Public\Pictures\Sample Pictures\Modified"</span>;
            System.IO.Directory.CreateDirectory(newDir);

            <span class="rem">//  Method signature: Parallel.ForEach(IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body)</span>
            Parallel.ForEach(files, currentFile =&gt;
            {
                <span class="rem">// The more computational work you do here, the greater </span>
                <span class="rem">// the speedup compared to a sequential foreach loop.</span>
                <span class="kwrd">string</span> filename = System.IO.Path.GetFileName(currentFile);
                System.Drawing.Bitmap bitmap = <span class="kwrd">new</span> System.Drawing.Bitmap(currentFile);

                bitmap.RotateFlip(System.Drawing.RotateFlipType.Rotate180FlipNone);
                bitmap.Save(System.IO.Path.Combine(newDir, filename));

                <span class="rem">// Peek behind the scenes to see how work is parallelized.</span>
                <span class="rem">// But be aware: Thread contention for the Console slows down parallel loops!!!</span>
                Console.WriteLine(<span class="str">"Processing {0} on thread {1}"</span>, filename,
                                    Thread.CurrentThread.ManagedThreadId);

            } <span class="rem">//close lambda expression</span>
                 ); <span class="rem">//close method invocation</span>

            <span class="rem">// Keep the console window open in debug mode.</span>
            Console.WriteLine(<span class="str">"Processing complete. Press any key to exit."</span>);
            Console.ReadKey();
        }
    }
}

注意：</pre><pre class="csharpcode">并行编程与之前的多线程的区别，并行编程其实可以理解为多核编程，它可以更好地利用多CPU的优势。而之前的多线程其实是需要切换线程的。</pre><pre class="csharpcode">&nbsp;</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>