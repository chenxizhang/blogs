# WPF：理解ContentControl&mdash;&mdash;动态添加控件和查找控件 
> 原文发表于 2010-03-25, 地址: http://www.cnblogs.com/chenxizhang/archive/2010/03/25/1694899.html 


<p>我认为WPF的核心改变之一就是控件模型发生了重要的变化，大的方面说，现在窗口中的控件（大部分）都没有独立的Hwnd了。而且控件可以通过所谓的模板提供各种各样的表现形式。</p> <p>这一篇就来谈一谈ContentControl，的第一部分，动态添加控件和查找控件</p> <p>什么是ContentControl呢？其实WPF的绝大部分的控件，还包括窗口本身都是继承自ContentControl的。</p> <p>&nbsp;</p> <p>有的时候，我们需要在窗口出来之后，再动态添加一些控件。例如一个最简单的场景：我们需要做一个扫雷程序，该扫雷程序根据用户选择的难易程度决定要显示多少个地雷。</p> <p>为了便于理解，大家可以看下面这三个图片</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_2.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_thumb.png" width="691" height="752"></a> </p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_4.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_thumb_1.png" width="691" height="752"></a> </p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_6.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_thumb_2.png" width="691" height="752"></a>&nbsp;</p> <p>ok，我们还是回想一下在Windows Forms里面怎么做？</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Windows.Forms;

<span class="kwrd">namespace</span> WindowsFormsApplication1
{
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> Form1 : Form
    {
        <span class="kwrd">public</span> Form1()
        {
            InitializeComponent();
        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> button1_Click(<span class="kwrd">object</span> sender, EventArgs e)
        {
            <span class="rem">//初级版，实例化6*6一共64个按钮</span>
            CreateButton(6, 6);
        }



        <span class="kwrd">private</span> <span class="kwrd">void</span> button2_Click(<span class="kwrd">object</span> sender, EventArgs e)
        {
            <span class="rem">//高级版，实例化9*9一共81个按钮</span>
            CreateButton(9, 9);
        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> CreateButton(<span class="kwrd">int</span> x, <span class="kwrd">int</span> y) {
            panel1.SuspendLayout();
            panel1.Controls.Clear();

            <span class="rem">//四个方向的边距都是5</span>
            <span class="kwrd">int</span> width = (panel1.Width-(x+1)*5)/x;
            <span class="kwrd">int</span> height = (panel1.Height-(y+1)*5)/y;




            <span class="kwrd">for</span> (<span class="kwrd">int</span> i = 0; i &lt; x; i++)
            {
                <span class="kwrd">for</span> (<span class="kwrd">int</span> j = 0; j &lt; y; j++)
                {
                    Button bt = <span class="kwrd">new</span> Button()
                    {
                        Width = width,
                        Height = height,
                        Left = i*width+5,
                        Top = j*height+5
                    };

                    panel1.Controls.Add(bt);
                    
                }
            }

            panel1.ResumeLayout();
        }


    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p></p>
<p></p>
<p></p>
<p>我们可以花一点点时间稍微解释一下，其实我们就是用循环的方式，动态地创建了一批按钮出来，然后将他们添加到Panel的Controls集合中去。</p>
<p>那么，同样的思路放在WPF中来是否可行呢？我们一步一步来看吧</p>
<p>首先，在WPF中进行布局控制有几个主要的容器</p>
<ul>
<li>Canvas是按照绝对位置定位的，很像上面的Panel这种机制；</li>
<li>StackPanel呢，则是基于流模式的，它没有绝对定位的概念，一批控件要么从左到右排列，要么从上而下排列</li>
<li>Grid，可能是用的最多的，它可以提供按照行和列的方式更好地组织控件。而事实上，在Grid里面也可以嵌入Canvas和StackPanel，他们结合可以构造出足够复杂的 界面。</li></ul>
<p>&nbsp;</p>
<p>那么，我们就来尝试用Canvas实现与Windows Forms类似的效果吧</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_8.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_thumb_3.png" width="596" height="520"></a> </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_10.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_thumb_4.png" width="596" height="520"></a> </p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_12.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/WPFContentControl_90E8/image_thumb_5.png" width="596" height="520"></a> </p>
<p>那么，我们的代码有什么区别呢？</p>
<p>第一部分是XAML代码</p><pre class="csharpcode"><span class="kwrd">&lt;</span><span class="html">Window</span> <span class="attr">x:Class</span><span class="kwrd">="WpfApplication1.Window1"</span>
    <span class="attr">xmlns</span><span class="kwrd">="http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>
    <span class="attr">xmlns:x</span><span class="kwrd">="http://schemas.microsoft.com/winfx/2006/xaml"</span>
    <span class="attr">Title</span><span class="kwrd">="我的扫雷程序"</span> <span class="attr">Height</span><span class="kwrd">="516"</span> <span class="attr">Width</span><span class="kwrd">="592"</span><span class="kwrd">&gt;</span>
    <span class="kwrd">&lt;</span><span class="html">Grid</span><span class="kwrd">&gt;</span>
        <span class="kwrd">&lt;</span><span class="html">Button</span> <span class="attr">Height</span><span class="kwrd">="23"</span> <span class="attr">HorizontalAlignment</span><span class="kwrd">="Left"</span> <span class="attr">Margin</span><span class="kwrd">="20,12,0,0"</span> <span class="attr">Name</span><span class="kwrd">="button1"</span> <span class="attr">VerticalAlignment</span><span class="kwrd">="Top"</span> <span class="attr">Width</span><span class="kwrd">="75"</span> <span class="attr">Click</span><span class="kwrd">="button1_Click"</span><span class="kwrd">&gt;</span>初级<span class="kwrd">&lt;/</span><span class="html">Button</span><span class="kwrd">&gt;</span>
        <span class="kwrd">&lt;</span><span class="html">Button</span> <span class="attr">Height</span><span class="kwrd">="23"</span> <span class="attr">HorizontalAlignment</span><span class="kwrd">="Left"</span> <span class="attr">Margin</span><span class="kwrd">="101,12,0,0"</span> <span class="attr">Name</span><span class="kwrd">="button2"</span> <span class="attr">VerticalAlignment</span><span class="kwrd">="Top"</span> <span class="attr">Width</span><span class="kwrd">="75"</span> <span class="attr">Click</span><span class="kwrd">="button2_Click"</span><span class="kwrd">&gt;</span>高级<span class="kwrd">&lt;/</span><span class="html">Button</span><span class="kwrd">&gt;</span>
        <span class="kwrd">&lt;</span><span class="html">Canvas</span> <span class="attr">Margin</span><span class="kwrd">="20,41,12,12"</span> <span class="attr">Name</span><span class="kwrd">="canvas1"</span>  <span class="kwrd">/&gt;</span>
    <span class="kwrd">&lt;/</span><span class="html">Grid</span><span class="kwrd">&gt;</span>
<span class="kwrd">&lt;/</span><span class="html">Window</span><span class="kwrd">&gt;</span>
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>第二部分是C#代码</p><pre class="csharpcode"><span class="kwrd">using</span> System.Windows;
<span class="kwrd">using</span> System.Windows.Controls;

<span class="kwrd">namespace</span> WpfApplication1
{
    <span class="rem">/// &lt;summary&gt;</span>
    <span class="rem">/// Window1.xaml 的交互逻辑</span>
    <span class="rem">/// &lt;/summary&gt;</span>
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> Window1 : Window
    {
        <span class="kwrd">public</span> Window1()
        {
            InitializeComponent();
        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> button1_Click(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {
            CreateButton(6, 6);
        }


        <span class="kwrd">private</span> <span class="kwrd">void</span> button2_Click(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {
            CreateButton(9, 9);
        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> CreateButton(<span class="kwrd">int</span> x, <span class="kwrd">int</span> y)
        {
            


            canvas1.Children.Clear();

            <span class="rem">//四个方向的边距都是5</span>
            <span class="kwrd">double</span> width = (<span class="kwrd">this</span>.canvas1.ActualWidth - (x + 1) * 5) / x;
            <span class="kwrd">double</span> height = (<span class="kwrd">this</span>.canvas1.ActualHeight - (y + 1) * 5) / y;




            <span class="kwrd">for</span> (<span class="kwrd">int</span> i = 0; i &lt; x; i++)
            {
                <span class="kwrd">for</span> (<span class="kwrd">int</span> j = 0; j &lt; y; j++)
                {
                    Button bt = <span class="kwrd">new</span> Button()
                    {
                        Width = width,
                        Height = height
                    };

                    Canvas.SetTop(bt, j * height + 5);
                    Canvas.SetLeft(bt, i * width + 5);
                    <span class="rem">//这两句很关键。按钮在Canvas中的定位与它自己的Left以及Top不是一个概念</span>
                    

                    canvas1.Children.Add(bt);
                    
                    
                }
            }

            
        }


    }
}
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>我们发现了以下区别</p>
<p>1. 现在没有Controls这个概念了，而是有一个Children属性，代表了所有的子内容</p>
<p>2.针对不同的容器，有一些特殊的方法来定位子元素。例如Canvas的SetTop等方法 。</p>