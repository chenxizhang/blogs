# XML序列化的时候如何支持Namespace 
> 原文发表于 2014-08-16, 地址: http://www.cnblogs.com/chenxizhang/p/3915960.html 


<p>我曾经不止一次（当然不仅仅是我意识到这个问题）说到过，XML标准中的Namespace的设计其实是一个较为失败的设计，它有它的优点，但缺点更多。
</p><p><a href="http://zzk.cnblogs.com/s?w=blog%3Achenxizhang+xml+%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4&amp;t">http://zzk.cnblogs.com/s?w=blog%3Achenxizhang+xml+%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4&amp;t</a>= 
</p><p>这里又有一个范例。我们需要在XML序列化的时候，更加小心地注意namespace的问题。
</p><p>下面有一个例子程序
</p><ol><li><div>数据实体模型（这个类是通过xsd工具自动生成的，具体用途这里就不做展开了
</div><p>//------------------------------------------------------------------------------
</p><p>// &lt;auto-generated&gt;
</p><p>//     This code was generated by a tool.
</p><p>//     Runtime Version:4.0.30319.18444
</p><p>//
</p><p>//     Changes to this file may cause incorrect behavior and will be lost if
</p><p>//     the code is regenerated.
</p><p>// &lt;/auto-generated&gt;
</p><p>//------------------------------------------------------------------------------
</p><p> 
 </p><p>using System.Xml.Serialization;
</p><p> 
 </p><p>// 
</p><p>// This source code was auto-generated by xsd, Version=4.0.30319.33440.
</p><p>// 
</p><p> 
 </p><p> 
 </p><p>/// &lt;remarks/&gt;
</p><p>[System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.0.30319.33440")]
</p><p>[System.SerializableAttribute()]
</p><p>[System.Diagnostics.DebuggerStepThroughAttribute()]
</p><p>[System.ComponentModel.DesignerCategoryAttribute("code")]
</p><p>[System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="http://schemas.microsoft.com/office/infopath/2003/myXSD/2014-08-15T22:37:24")]
</p><p>[System.Xml.Serialization.XmlRootAttribute(Namespace="http://schemas.microsoft.com/office/infopath/2003/myXSD/2014-08-15T22:37:24", IsNullable=false)]
</p><p>public partial class myFields {
</p><p>    
 </p><p>    private string titleField;
</p><p>    
 </p><p>    private System.Xml.XmlAttribute[] anyAttrField;
</p><p>    
 </p><p>    /// &lt;remarks/&gt;
</p><p>    public string Title {
</p><p>        get {
</p><p>            return this.titleField;
</p><p>        }
</p><p>        set {
</p><p>            this.titleField = value;
</p><p>        }
</p><p>    }
</p><p>    
 </p><p>    /// &lt;remarks/&gt;
</p><p>    [System.Xml.Serialization.XmlAnyAttributeAttribute()]
</p><p>    public System.Xml.XmlAttribute[] AnyAttr {
</p><p>        get {
</p><p>            return this.anyAttrField;
</p><p>        }
</p><p>        set {
</p><p>            this.anyAttrField = value;
</p><p>        }
</p><p>    }
</p><p>}<span>
				</span></p><p>
 </p></li><li><div>实际对应的XML文档应该是下面这样的。注意，下面有一个my的命名空间。
</div><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;?mso-infoPathSolution solutionVersion="1.0.0.3" productVersion="15.0.0" PIVersion="1.0.0.0" href="file:///C:\Users\chenxizhang\AppData\Local\Microsoft\InfoPath\Designer4\46fec1056ed24f25\manifest.xsf" ?&gt;&lt;?mso-application progid="InfoPath.Document" versionProgid="InfoPath.Document.4"?&gt;&lt;my:myFields <span><strong>xmlns:my="http://schemas.microsoft.com/office/infopath/2003/myXSD/2014-08-15T22:37:24"</strong>
				</span>xml:lang="en-us"&gt;
</p><p>    <strong><span>&lt;my:Title&gt;test&lt;/my:Title&gt;</span>
				</strong></p><p>&lt;/my:myFields&gt;
</p></li><li><div>为了使得XML序列化的时候，正常地生成这样的一份文档。我们需要做如下的特殊设计
</div><p>
 </p><p>using System;
</p><p>using System.IO;
</p><p>using System.Xml.Serialization;
</p><p> 
 </p><p>namespace ConsoleApplication1
</p><p>{
</p><p>    class Program
</p><p>    {
</p><p>        static void Main(string[] args)
</p><p>        {
</p><p>            
 </p><p>            //1.<span>准备数据</span>
			</p><p>            var data = new myFields() { Title = "CEO" };
</p><p>            //2.<span>准备命名空间</span>
			</p><p><strong>            var ns = new XmlSerializerNamespaces();
</strong></p><p><strong>            ns.Add("my", "http://schemas.microsoft.com/office/infopath/2003/myXSD/2014-08-15T22:37:24");
</strong></p><p>            //3.<span>准备序列化器</span>
			</p><p>            var serializer = new XmlSerializer(typeof(myFields));
</p><p>            //4.<span>准备用来接收的内存流</span>
			</p><p>            var ms = new MemoryStream();
</p><p>            //5.<span>执行序列化</span>
			</p><p>            <strong>serializer.Serialize(ms, data, ns);
</strong></p><p> 
 </p><p>            //6.<span>将内容读取出来</span>
			</p><p>            var reader = new StreamReader(ms);
</p><p>            ms.Position = 0;
</p><p>            Console.WriteLine(reader.ReadToEnd());
</p><p>            //7.<span>关闭流</span>
			</p><p>            reader.Close();
</p><p>            ms.Close();
</p><p> 
 </p><p>            Console.Read();
</p><p>        }
</p><p>    }
</p><p>}
</p><p>
 </p></li></ol><p>不太难，但是确实是多了些步骤，不是吗</p>