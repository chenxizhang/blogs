# 如何在Windows Forms应用程序中实现可组装式(Composite)的架构以及松耦合事件机制 
> 原文发表于 2011-08-15, 地址: http://www.cnblogs.com/chenxizhang/archive/2011/08/15/2139317.html 


<p>越来越多人都逐渐了解了在WPF和Silverlight平台上的一个可组装式框架，它的正式名称是Prism，你可以在下面的地址找到很多学习资源</p> <p><a href="http://compositewpf.codeplex.com/">http://compositewpf.codeplex.com/</a></p> <p>&nbsp;</p> <p>下面这里还有一套很不错的视频</p> <p><a href="http://www.tudou.com/playlist/id/9143859">http://www.tudou.com/playlist/id/9143859</a></p> <p>&nbsp;</p> <p>是的，据我对Prism的了解，我觉得它的确是一个很不错的框架，非常好的想法，我不得不说，大家都应该或多或少地对其有所学习和了解。事实上，很多想法，我们或许也有过，或者在以前的项目中实践过，而这是微软官方提供的框架，至少我是从中也学到了很多东西。</p> <p>&nbsp;</p> <p>那么，现在有一个问题就是，既然Prism是个不错的框架，那么能不能用在Windows Forms应用程序里面呢？答案是：不可以。</p> <p>噢。。。先不要着急沮丧，也不要开始扔你桌子上的东西，这并不是什么大不了的事情，世界不会停止转动。你懂的。</p> <p>&nbsp;</p> <p>我这里实现了一套类似的框架，出于演示目的，我大大简化了有关的细节，但大家通过学习也可以了解，并不是那么难，而且这是你自己的Prism，是你通过学习转换为自己的知识。</p> <p>&nbsp;</p> <p>那么，来看看这个演示程序吧</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156219185.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156223296.png" width="409" height="704"></a></p> <p>备注：</p> <ul> <li>Common目录中的东西是每个模块都要公用的，例如对象定义，事件定义等</li> <li>Modules目录中的东西是可以不断添加的模块，例如客户管理，订单管理等</li> <li>MainApplication是主程序</li></ul> <p>我知道有人已经等不及了，那么我们就来看看到底这是一个什么效果吧</p> <p>首先，这是一个可以组装的程序，就是可以通过添加Module来丰富MainApplication的功能，例如下面这样</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156226644.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/20110815115622755.png" width="660" height="278"></a></p> <p>我是将每个模块，都定义一个工具栏按钮。</p> <p>点击之后，两个模块的显示效果如下</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156223546.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156227657.png" width="660" height="553"></a></p> <p>&nbsp;</p> <p>如果光是这样，也没有什么大不了的。虽然它也很重要，它实现了模块化开发和组装。它们不管在开发阶段，还是在使用阶段，都是没有直接依赖的。</p> <p>然后，我这个例子还实现了松耦合的事件机制，就是：虽然这些模块之间确实没有任何依赖，但是，我们可以实现类似Prism那种EventAggregator机制，也就是说，它们之间仍然可以通讯。</p> <p>&nbsp;</p> <p>例如，<strong>如果这两个模块的窗口都显示出来的情况下，我可能希望在Customer Module里面下了一个订单，能立即在Order Module里面显示出来（请注意，Customer Module里面是不可能直接访问到Order Module的控件的，严格意义上说，它根本不知道是否有Order Module），我们该如何做到呢？</strong></p> <p><strong></strong>&nbsp;</p>  <p>Good question! 哲学告诉我们，问题的答案往往就在问题本身。所以，提问题，提正确的问题，是多么重要</p> <p>答案就是：Event Aggregation。你可以通过范例代码知道这个小精灵是如何工作的。现在，还是让我们来看一下效果吧</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156239053.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156233164.png" width="660" height="553"></a></p> <p>首先，我们在右侧的界面中添加订单信息，然后点击“Create Order”按钮</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156231179.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156233970.png" width="660" height="553"></a></p> <p>我们立即就发现，在左侧的订单列表中添加了一条记录。这就是我们需要的，对吧</p> <p>&nbsp;</p> <p>所以，综上所述，我在这个范例中实现了两个主要功能</p> <p>1.动态组装模块</p> <p>2.模块之间的松耦合事件</p> <p>&nbsp;</p> <p>下面我将大致解释一下内部的原理，大家可以通过下面链接下载到源代码，并且跟我的步骤来进行学习。这些代码并不见得是最优化的，欢迎自行修改</p> <p><a title="http://files.cnblogs.com/chenxizhang/WindowsFormsCompisitionFrameworkSample.rar" href="http://files.cnblogs.com/chenxizhang/WindowsFormsCompisitionFrameworkSample.rar">http://files.cnblogs.com/chenxizhang/WindowsFormsCompisitionFrameworkSample.rar</a></p>  <p>&nbsp;</p> <p>整个架构的核心技术是：MEF,Managed Extensibility Framework <p>这一篇文章并不是普及MEF的基础文章，事实上，我发现有很多这方面的文章，例如 <p><a href="http://zzk.cnblogs.com/s?w=MEF">http://zzk.cnblogs.com/s?w=MEF</a> <p>MEF的官方站点是： <p><a href="http://mef.codeplex.com/">http://mef.codeplex.com/</a> <p>顺便说一下，Prism从4.0开始，也直接支持MEF来做为组装技术，之前它仅支持Unity Container的方式。 <p>&nbsp; <p>我依次来解释一下有关组件以及他们的关系 <h1>Framework项目</h1> <p>这个项目是定义了框架级别的一些接口和类型，例如事件的基类，事件聚合器及其实现。这是一个Class Library项目，需要添加一个特殊的引用：System.ComponentModel.Composition.dll</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156241985.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156243065.png" width="360" height="262"></a></p> <p>&nbsp;</p> <p>IEventAgregator,这是一个接口，因为我们是要实现聚合器，所以需要支持多个事件。这里我们公开了一个方法，GetEvent，可以根据事件类型获取事件的实例</p> <p>&nbsp;</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="kwrd">namespace</span> Framework
{
    <span class="rem">/// &lt;summary&gt;</span>
    <span class="rem">/// 事件聚合器的接口</span>
    <span class="rem">/// &lt;/summary&gt;</span>
    <span class="kwrd">public</span> <span class="kwrd">interface</span> IEventAggregator
    {
        T GetEvent&lt;T&gt;();
    }
}
</pre>
<p>EventAggregator:这是对IEventAggregator的具体实现。这里用一个列表保存了所有的事件的实例。</p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;
<span class="kwrd">using</span> System.ComponentModel.Composition;


<span class="kwrd">namespace</span> Framework
{
    [Export(<span class="kwrd">typeof</span>(IEventAggregator))]
    <span class="kwrd">public</span> <span class="kwrd">class</span> EventAggregator:IEventAggregator
    {

        <span class="kwrd">private</span> List&lt;EventBase&gt; events = <span class="kwrd">new</span> List&lt;EventBase&gt;();


        <span class="preproc">#region</span> IEventAggregator Members

        <span class="kwrd">public</span> T GetEvent&lt;T&gt;()
        {
            <span class="rem">//如果事件存在就返回，否则创建一个新的</span>
            <span class="kwrd">if</span>(events.OfType&lt;T&gt;().FirstOrDefault() == <span class="kwrd">null</span>)
            {
                var evt = Activator.CreateInstance&lt;T&gt;();
                events.Add(evt <span class="kwrd">as</span> EventBase);
            }


            var result = events.OfType&lt;T&gt;().FirstOrDefault();

            <span class="kwrd">return</span> result;

        }

        <span class="preproc">#endregion</span>
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>&nbsp;</p>
<p>EventBase和CompositePresentationEvent，这两个是定义事件的基类。我们规定，在模块中所有的事件，必须基于ComositePresentationEvent进行实现。这个类型，我们提供了两个方法，Publish是触发某个事件，而Subscribe则是订阅某个事件。</p>
<p>&nbsp;</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="kwrd">namespace</span> Framework
{
    <span class="kwrd">public</span> <span class="kwrd">class</span> EventBase
    {
    }


    <span class="kwrd">public</span> <span class="kwrd">class</span> CompositePresentationEvent&lt;T&gt;:EventBase
        <span class="kwrd">where</span> T:<span class="kwrd">new</span>()
    {
        <span class="rem">//这里保存所有的处理程序</span>
        <span class="kwrd">private</span> List&lt;Action&lt;T&gt;&gt; handlers = <span class="kwrd">new</span> List&lt;Action&lt;T&gt;&gt;();


        <span class="kwrd">public</span> <span class="kwrd">void</span> Subscribe(Action&lt;T&gt; callback)
        {
            <span class="rem">///将处理程序添加到集合中</span>
            handlers.Add(callback);
        }

        <span class="kwrd">public</span> <span class="kwrd">void</span> Publish(T parameter)
        {
            <span class="rem">///依次执行所有的处理程序</span>
            handlers.ForEach(a =&gt; a(parameter));
        }

    }
}
</pre><pre class="csharpcode">&nbsp;</pre>
<p>&nbsp;</p>
<h1>Events项目</h1>
<p>这个项目定义了在当前应用程序，所有模块之间需要公用的一些事件定义，它需要引用两个程序集：Framework,和Models</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156243904.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/20110815115624524.png" width="292" height="248"></a></p>
<p>这里只有一个类型，定义了一个事件类别，CreateOrderEvent，它的基类是CompositePresentationEvent，需要传递的数据是Order</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;
<span class="kwrd">using</span> Framework;
<span class="kwrd">using</span> Models;

<span class="kwrd">namespace</span> Events
{
    <span class="kwrd">public</span> <span class="kwrd">class</span> CreateOrderEvent:CompositePresentationEvent&lt;Order&gt;
    {
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>&nbsp;</p>
<h1>Models项目</h1>
<p>这个项目定义了在所有模块之间共享的业务实体类型，例如本例中用到的Order类型，它表示一个订单信息</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="kwrd">namespace</span> Models
{
    <span class="kwrd">public</span> <span class="kwrd">class</span> Order
    {
        <span class="kwrd">public</span> <span class="kwrd">int</span> OrderID { get; set; }
        <span class="kwrd">public</span> <span class="kwrd">string</span> CustomerID { get; set; }

        <span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">string</span> ToString()
        {
            <span class="kwrd">return</span> <span class="kwrd">string</span>.Format(<span class="str">"OrderID:{0}, CustomerID:{1}"</span>, OrderID, CustomerID);
        }
    }
}
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>&nbsp;</p>
<p>接下来，我们看看模块里面应该如何实现</p>
<p>本例中我已经实现了两个简单的模块，他们都是标准的Class Library项目。里面各自包含了一个控件，我让每个控件成为该模块的主界面。</p>
<h1>CustomerModule项目</h1>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156247459.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156253523.png" width="352" height="366"></a></p>
<p>该项目，需要有四个外部引用（换句话说，任何模块都应该需要这四个引用）</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/201108151156252966.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201108/20110815115625458.png" width="392" height="484"></a></p>
<p>我们提供了一个用户控件做为主界面。它看起来像是上面这样。并且它拥有下面这样的后台代码</p>
<p>&nbsp;</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.ComponentModel.Composition;
<span class="kwrd">using</span> System.Windows.Forms;
<span class="kwrd">using</span> Events;
<span class="kwrd">using</span> Framework;
<span class="kwrd">using</span> Models;


<span class="kwrd">namespace</span> CustomerModule
{
    [Export(<span class="kwrd">typeof</span>(UserControl))]
    [ExportMetadata(<span class="str">"ModuleName"</span>,<span class="str">"Customer Module"</span>)]
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> UserControl1 : UserControl
    {
        <span class="kwrd">public</span> UserControl1()
        {
            InitializeComponent();
        }


        [Import]
        <span class="kwrd">public</span> IEventAggregator EventAggregator { get; set; }

        <span class="kwrd">private</span> <span class="kwrd">void</span> button1_Click(<span class="kwrd">object</span> sender, EventArgs e)
        {
            <span class="kwrd">if</span>(EventAggregator != <span class="kwrd">null</span>)
            {
                EventAggregator.GetEvent&lt;CreateOrderEvent&gt;().Publish(<span class="kwrd">new</span> Order()
                {
                    OrderID = <span class="kwrd">int</span>.Parse(txtOrderID.Text),
                    CustomerID = txtCustomerID.Text
                });
            }
        }
        
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>首先，我们看到在Class上面，添加了Export和ExportMetadata两个Attribute，这是MEF的核心要素，也就是说，如果这个部件需要能够动态组合，它就必须导出(Export)。</p>
<p>&nbsp;</p>
<p>然后，这里比较特殊的还有那个EventAggregator的属性，我们添加了一个Import的Attribute。这是干什么的呢？我们这里也没有看到谁对它进行赋值。其实，这个属性肯定不是在Module里面赋值的，是由主程序提供的。这也就是MEF的魔力之一：</p>
<ul>
<li>某个部件需要支持动态组装，就提供Export</li>
<li>我需要用到其他一个部件，虽然我不知道谁会给我，我只要声明Import</li></ul>
<p>仔细想想吧，很酷，不是吗？</p>
<p>我们现在是在Customer 模块里，刚才说了，我希望在这个模块里面做的一个操作，能够用某种方式通知其他模块。所以，请注意，在Button1_Click事件中，我们Publish了一个事件，或者称之为触发了某个事件。松耦合在这里表现得淋漓尽致：<strong>你发布事件，你不需要知道谁会响应事件，或者用什么形式响应。</strong></p>
<p>我们再来看一下订单模块吧</p>
<h1>OrderModule项目</h1>
<p>这个项目与CustomerModule有很多相似之处，除了代码。它作为事件的消费者，在启动之后，订阅了CreateOrderEvent事件。</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.ComponentModel.Composition;
<span class="kwrd">using</span> System.Windows.Forms;
<span class="kwrd">using</span> Events;
<span class="kwrd">using</span> Framework;

<span class="kwrd">namespace</span> OrderModule
{
    [Export(<span class="kwrd">typeof</span>(UserControl))]
    [ExportMetadata(<span class="str">"ModuleName"</span>,<span class="str">"Order Module"</span>)]
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> UserControl1 : UserControl
    {
        <span class="kwrd">public</span> UserControl1()
        {
            InitializeComponent();


            Load += <span class="kwrd">new</span> EventHandler(UserControl1_Load);
        }

        <span class="kwrd">void</span> UserControl1_Load(<span class="kwrd">object</span> sender, EventArgs e)
        {

            EventAggregator.GetEvent&lt;CreateOrderEvent&gt;().Subscribe((o) =&gt;
            {
                listBox1.Items.Add(o);
            });
        }

        [Import]
        <span class="kwrd">public</span> IEventAggregator EventAggregator { get; set; }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>&nbsp;</p>
<h1>MainApplication项目</h1>
<p>这个项目，实现了动态加载模块，并且将它们绑定在工具栏上面，请参考下面代码和注释吧</p>
<p>&nbsp;</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.ComponentModel.Composition;
<span class="kwrd">using</span> System.ComponentModel.Composition.Hosting;
<span class="kwrd">using</span> System.IO;
<span class="kwrd">using</span> System.Windows.Forms;
<span class="kwrd">using</span> Framework;


<span class="kwrd">namespace</span> MainApplication
{
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> Form1 : Form,IPartImportsSatisfiedNotification
    {
        <span class="kwrd">public</span> Form1()
        {
            InitializeComponent();
        }

        <span class="kwrd">protected</span> <span class="kwrd">override</span> <span class="kwrd">void</span> OnLoad(EventArgs e)
        {

            <span class="rem">//这里一方面要加载那些模块，还要加载Framework，因为里面有一个默认实现好的EventAggregator</span>
            var catalog = <span class="kwrd">new</span> AggregateCatalog(
                <span class="kwrd">new</span> DirectoryCatalog(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, <span class="str">"modules"</span>)),<span class="rem">//所有的模块必须放在应用程序根目录下面的modules目录</span>
                <span class="kwrd">new</span> AssemblyCatalog(<span class="kwrd">typeof</span>(EventAggregator).Assembly));

            var container = <span class="kwrd">new</span> CompositionContainer(catalog);

            <span class="rem">//立即组装这个EventAggregator部件,明确地定义</span>
            container.ComposeExportedValue&lt;IEventAggregator&gt;(<span class="kwrd">new</span> EventAggregator());

            <span class="rem">//执行导入</span>
            container.SatisfyImportsOnce(<span class="kwrd">this</span>);


            <span class="kwrd">base</span>.OnLoad(e);

        }

        <span class="rem">//导入多个模块，以及它们的元数据</span>
        [ImportMany(<span class="kwrd">typeof</span>(UserControl),AllowRecomposition=<span class="kwrd">true</span>)]
        <span class="kwrd">public</span> Lazy&lt;UserControl,Dictionary&lt;<span class="kwrd">string</span>,<span class="kwrd">object</span>&gt;&gt;[] Modules { get; set; }

        <span class="preproc">#region</span> IPartImportsSatisfiedNotification Members

        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// 当导入成功时触发该方法</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="kwrd">public</span> <span class="kwrd">void</span> OnImportsSatisfied()
        {
            <span class="rem">//循环所有模块，并且添加工具栏按钮，绑定事件</span>
            Array.ForEach&lt;Lazy&lt;UserControl, Dictionary&lt;<span class="kwrd">string</span>, <span class="kwrd">object</span>&gt;&gt;&gt;(Modules, l =&gt;
            {
                var toolItem = <span class="kwrd">new</span> ToolStripButton(l.Metadata[<span class="str">"ModuleName"</span>].ToString());
                toolItem.Click += (o, a) =&gt; {
                    var form = <span class="kwrd">new</span> Form();
                    form.Text = toolItem.Text;
                    l.Value.Dock = DockStyle.Fill;
                    form.Controls.Add(l.Value);
                    form.MdiParent = <span class="kwrd">this</span>;
                    form.Show();
                    <span class="kwrd">this</span>.LayoutMdi(MdiLayout.TileVertical);
                };

                toolStrip1.Items.Add(toolItem);
            });
        }

        <span class="preproc">#endregion</span>
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>


<p>&nbsp;</p>
<p>这个项目介绍到这里，有兴趣的朋友，可以研究一下，并且尝试添加一些新模块。欢迎你在这个基础上进行修改，实现真正能满足你需求的框架。</p>
<p>&nbsp;</p>
<p>本文代码，请通过下面地址下载</p>
<p><a title="http://files.cnblogs.com/chenxizhang/WindowsFormsCompisitionFrameworkSample.rar" href="http://files.cnblogs.com/chenxizhang/WindowsFormsCompisitionFrameworkSample.rar">http://files.cnblogs.com/chenxizhang/WindowsFormsCompisitionFrameworkSample.rar</a></p>