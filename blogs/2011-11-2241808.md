# 如何通过编程方式将SharePoint中的Infopath表单及附件进行归档 
> 原文发表于 2011-11-08, 地址: http://www.cnblogs.com/chenxizhang/archive/2011/11/08/2241808.html 


<p>事情是这样的：我们通过Infopath设计了一些电子表单，用来在企业内部进行一些流程审批的载体。结合SharePoint Server所提供的Forms Service，我们可以比较便捷地实现，在线填写也很方便，如下图所示</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082257565290.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082257587949.png" width="828" height="588"></a></p> <p>在浏览器中填写的效果如下</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258027520.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258046417.png" width="931" height="635"></a></p> <p>注意：这只是一个演示表单，我简单做了几个字段而已。重点要体现附件。</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258154214.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/20111108225816146.png" width="931" height="635"></a></p> <p>&nbsp;</p> <p>那么，现在的需求是这样：因为这些表单越来越多，而且大多有附件，导致SharePoint的内容数据库越来越大，速度受到一定的影响。用户想到一个做法，就是定期将那些已经完成审批的表单归档，而且从这个表单库中删除掉。</p> <p>在归档的时候，就会遇到一个问题，<font color="#ff0000" size="4"><strong>如何将附件也归档，并且放到指定的磁盘文件夹上去</strong></font>。</p> <p>&nbsp;</p> <p>首先，我们需要了解的是，Infopath的附件默认是怎么存储的呢？Infopath表单其实就是一份特殊的XML文件，它会将所有的信息，包括附件在内都保存在一个XML文件中。当然，附件会通过编码成Base64的字符串保存。我们可以将之前填写好的这个表单保存下来一份数据，以便了解它里面的结构</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258189980.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258204242.png" width="933" height="530"></a></p> <p>这个文件，我们可以用记事本直接打开</p> <p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258218504.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258323968.png" width="1028" height="711"></a></p> <p>大家可以看到，其实附件的内容都是保存在这个xml文件里面的。</p> <p>通过一些研究，我实现了如下的解决方案，这是一个原型，可以作为一个参考。</p> <p>【备注】具体在做的时候，还要细致一些将所有数据都妥善保存，本例<font color="#ff0000"><strong>重点演示如何保存附件</strong></font>。其他常规的数据应该很容易处理。可以读取出来存放在数据库中的一个表中。</p> <p>&nbsp;</p> <p>下面这个类型是我在网上找到的，不是我的原创。这个类型是一个解码器，可以将上面的Base64String还原为一个字节数组</p><pre class="csharpcode">  <span class="kwrd">using</span> System;

    <span class="kwrd">using</span> System.Collections.Generic;

    <span class="kwrd">using</span> System.Text;


    <span class="kwrd">using</span> System.IO;


    <span class="rem">/// &lt;summary&gt;</span>

    <span class="rem">/// Class used to decode an InfoPath attachment.</span>

    <span class="rem">/// Pulls the file name and the decoded file from either a base 64 byte array or string.</span>

    <span class="rem">/// &lt;/summary&gt;</span>

    <span class="kwrd">public</span> <span class="kwrd">class</span> InfoPathAttachmentDecoder
    {

        <span class="rem">// Private string to hold the attachment name.</span>

        <span class="kwrd">string</span> _fileName;


        <span class="rem">// Private byte array to hold the decoded attachment.</span>

        <span class="kwrd">byte</span>[] _decodedFile;


        <span class="rem">/// &lt;summary&gt;</span>

        <span class="rem">/// The name of the file within the InfoPath attachment.</span>

        <span class="rem">/// &lt;/summary&gt;</span>

        <span class="kwrd">public</span> <span class="kwrd">string</span> Filename
        {

            get { <span class="kwrd">return</span> _fileName; }

        }


        <span class="rem">/// &lt;summary&gt;</span>

        <span class="rem">/// The decoded file within the InfoPath attachment.</span>

        <span class="rem">/// &lt;/summary&gt;</span>

        <span class="kwrd">public</span> <span class="kwrd">byte</span>[] DecodedFile
        {

            get { <span class="kwrd">return</span> _decodedFile; }

        }


        <span class="rem">/// &lt;summary&gt;</span>

        <span class="rem">/// Constructor for the InfoPathAttachmentDecoder Class</span>

        <span class="rem">/// &lt;/summary&gt;</span>

        <span class="rem">/// &lt;param name="base64EncodedString"&gt;The attachment represented by a string&lt;/param&gt;</span>

        <span class="kwrd">public</span> InfoPathAttachmentDecoder(<span class="kwrd">string</span> base64EncodedString)
        {

            <span class="rem">// Use unicode encoding.</span>

            Encoding _encoding = Encoding.Unicode;


            <span class="rem">// The byte array containing the data.</span>

            <span class="kwrd">byte</span>[] _data = Convert.FromBase64String(base64EncodedString);


            <span class="rem">// Use a memory stream to access the data.</span>

            <span class="kwrd">using</span>(MemoryStream _memoryStream = <span class="kwrd">new</span> MemoryStream(_data))
            {

                <span class="rem">// Create a binary reader from the stream.</span>

                BinaryReader _theReader = <span class="kwrd">new</span> BinaryReader(_memoryStream);


                <span class="rem">// Create a byte array to hold the header data.</span>

                <span class="kwrd">byte</span>[] _headerData = _theReader.ReadBytes(16);


                <span class="rem">// Find the file size before finding the file name.</span>

                <span class="kwrd">int</span> _fileSize = (<span class="kwrd">int</span>)_theReader.ReadUInt32();


                <span class="rem">// Get the file name.</span>

                <span class="kwrd">int</span> _attachmentNameLength = (<span class="kwrd">int</span>)_theReader.ReadUInt32() * 2;

                <span class="kwrd">byte</span>[] _fileNameBytes = _theReader.ReadBytes(_attachmentNameLength);

                _fileName = _encoding.GetString(_fileNameBytes, 0, _attachmentNameLength - 2);


                <span class="rem">// Get the decoded attachment. </span>

                _decodedFile = _theReader.ReadBytes(_fileSize);

            }

        }


        <span class="rem">/// &lt;summary&gt;</span>

        <span class="rem">/// Constructor for the InfoPathAttachmentDecoder Class</span>

        <span class="rem">/// &lt;/summary&gt;</span>

        <span class="rem">/// &lt;param name="base64EncodedBytes"&gt;The attachment represented by a byte array&lt;/param&gt;</span>

        <span class="kwrd">public</span> InfoPathAttachmentDecoder(<span class="kwrd">byte</span>[] base64EncodedBytes) : <span class="kwrd">this</span>(Convert.ToBase64String(base64EncodedBytes)) { }


        <span class="rem">/// &lt;summary&gt;</span>

        <span class="rem">/// Static method that gets the file from the attachment.</span>

        <span class="rem">/// &lt;/summary&gt;</span>

        <span class="rem">/// &lt;param name="base64EncodedString"&gt;The attachment represented by a string&lt;/param&gt;</span>

        <span class="rem">/// &lt;returns&gt;Returns a byte array of the file in the attachment.&lt;/returns&gt;</span>

        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">byte</span>[] DecodeInfoPathAttachment(<span class="kwrd">string</span> base64EncodedString)
        {

            <span class="rem">// Create an instance of the InfoPathAttachmentDecoder</span>

            InfoPathAttachmentDecoder _infoPathAttachmentDecoder = <span class="kwrd">new</span> InfoPathAttachmentDecoder(base64EncodedString);


            <span class="rem">// Return the decoded file.</span>

            <span class="kwrd">return</span> _infoPathAttachmentDecoder.DecodedFile;

        }


        <span class="rem">/// &lt;summary&gt;</span>

        <span class="rem">/// Static method that gets the file from the attachment.</span>

        <span class="rem">/// &lt;/summary&gt;</span>

        <span class="rem">/// &lt;param name="base64EncodedBytes"&gt;The attachment represented by a byte array&lt;/param&gt;</span>

        <span class="rem">/// &lt;returns&gt;Returns a byte array of the file in the attachment.&lt;/returns&gt;</span>

        <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">byte</span>[] DecodeInfoPathAttachment(<span class="kwrd">byte</span>[] base64EncodedBytes)
        {

            <span class="rem">// Create an instance of the InfoPathAttachmentDecoder</span>

            InfoPathAttachmentDecoder _infoPathAttachmentDecoder = <span class="kwrd">new</span> InfoPathAttachmentDecoder(base64EncodedBytes);


            <span class="rem">// Return the decoded file.</span>

            <span class="kwrd">return</span> _infoPathAttachmentDecoder.DecodedFile;

        }
    }</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>&nbsp;</p>
<p>然后，我们需要实现对XML文档的读取。虽然读XML文件向来都不是什么大问题，但Infopath的XML文档结构还是挺繁琐的，有很多命名空间，直接读取相当费时费力。我一般会用下面的方式</p>
<p>&nbsp;</p>
<p>1. 打开Visual Studio Command Prompt</p>
<p>2. 根据xml文件生成xsd（架构）</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258343836.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/20111108225835116.png" width="681" height="446"></a></p>
<p>3.根据xsd文件生成一个强类型的class</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/20111108225844205.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258498663.png" width="681" height="446"></a></p>
<p>&nbsp;</p>
<p>准备工作做好了，下面我们做一个简单的程序来实现一下整个存档的逻辑</p>
<h2>1. 创建一个Windows Forms程序</h2>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258501007.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258526938.png" width="959" height="664"></a></p>
<p>【注意】选择.NET Framework 3.5</p>
<p>&nbsp;</p>
<h2>2. 设置编译平台为x64（这是访问SharePoint服务器对象模型的要求）</h2>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/20111108225853394.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258549149.png" width="730" height="385"></a></p>
<p>&nbsp;</p>
<h2>3. 做一个简单的界面如下</h2>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082258569017.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/20111108225906926.png" width="584" height="406"></a></p>
<p>&nbsp;</p>
<h2>4. 引用Microsoft.SharePoint.dll</h2>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/20111108225910496.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082259183608.png" width="319" height="237"></a></p>
<p>&nbsp;</p>
<h2>5. 将之前生成好的10248.cs和写好的InfoPathAttachmentDecoder 类型添加到项目中来</h2>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082259228685.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082259272650.png" width="354" height="274"></a></p>
<p>&nbsp;</p>
<h2>6.编写代码</h2><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.IO;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Windows.Forms;
<span class="kwrd">using</span> System.Xml.Serialization;
<span class="kwrd">using</span> Microsoft.SharePoint;

<span class="kwrd">namespace</span> FormArchiver
{
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> MainForm : Form
    {
        <span class="kwrd">public</span> MainForm()
        {
            InitializeComponent();
        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> btStart_Click(<span class="kwrd">object</span> sender, EventArgs e)
        {
            var path = txtLibPath.Text;
            var folder = txtFolder.Text;

            var site = <span class="kwrd">new</span> SPSite(path);
            var web = site.OpenWeb();
            var list = web.GetList(path);
            var items = list.Items;
            <span class="kwrd">foreach</span>(SPListItem item <span class="kwrd">in</span> items)
            {
                var file = item.File;
                var stream = file.OpenBinaryStream();
                var serializer = <span class="kwrd">new</span> XmlSerializer(<span class="kwrd">typeof</span>(myFields));<span class="rem">//这里的myFields这个类型，是之前通过xsd工具根据表单结构生成的</span>

                var result =(myFields) serializer.Deserialize(stream);
                var attachment = <span class="kwrd">new</span> InfoPathAttachmentDecoder(result.group3.FirstOrDefault().field4);
                var fileName = attachment.Filename;
                var buffer = attachment.DecodedFile;

                <span class="kwrd">if</span>(!Directory.Exists(folder))
                    Directory.CreateDirectory(folder);

                var targetPath = Path.Combine(folder, fileName);
                File.WriteAllBytes(targetPath, buffer);

            }

            MessageBox.Show(<span class="str">"保存完成"</span>);
        }
    }
}
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>这个程序运行起来的效果大致如下</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082259286106.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082259292386.png" width="433" height="289"></a></p>
<p>&nbsp;</p>
<p>点击“开始”，很快的我们就可以将附件保存出来到预设的目录</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082259324347.png"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/201111/201111082259332546.png" width="905" height="644"></a></p>
<p>&nbsp;</p>
<p>这个演示程序的源代码，请通过这里下载</p>
<p><a title="FormArchiver.rar" href="http://files.cnblogs.com/chenxizhang/FormArchiver.rar">FormArchiver.rar</a></p>