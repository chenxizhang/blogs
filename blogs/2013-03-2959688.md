# 再谈CLR查找和加载程序集的方式 
> 原文发表于 2013-03-14, 地址: http://www.cnblogs.com/chenxizhang/archive/2013/03/14/2959688.html 


<p>这是一个老问题，以前也有朋友写过一些文章介绍，但可能还不是很全面。我也多次被人问到，这里结合案例再次谈谈，希望对大家有所帮助。</p> <p>本文范例代码可以通过这里下载 <a title="http://files.cnblogs.com/chenxizhang/AssemblyMatchDemoSolution.zip" href="http://files.cnblogs.com/chenxizhang/AssemblyMatchDemoSolution.zip">http://files.cnblogs.com/chenxizhang/AssemblyMatchDemoSolution.zip</a><br></p> <p>根据程序集的特征，讨论这个问题，我们大致上有两个分类</p> <h1>没有做强名称签名的程序集</h1> <p>对于这种情况，CLR查找和加载程序集的方式如下</p> <ol> <li>程序的根目录</li> <li>根目录下面，与被引用程序集同名的子目录</li> <li>根目录下面被明确定义为私有目录的子目录</li></ol> <p>同时，这种情况下，如果有定义codebase，则codebase的优先级最高，而且如果codebase指定的路径找不到，则直接报告错误，不再查找其他目录</p> <p>&nbsp;</p> <h1>有做强名称签名的程序集</h1> <p>对于这种情况，CLR查找和加载程序集的方式如下</p> <ol> <li>全局程序集缓存</li> <li>如果有定义codebase，则以codebase定义为准，如果codebase指定的路径找不到，则直接报告错误</li> <li>程序的根目录</li> <li>根目录下面，与被引用程序集同名的子目录</li> <li>根目录下面被明确定义为私有目录的子目录</li></ol> <p>&nbsp;</p> <p>我们帮助大家更好地理解以上的说明，我准备用范例来做讲解。</p> <p>&nbsp;</p> <ol><!--EndFragment--></ol> <h1>1.准备基本范例</h1> <p>下面的范例演示了一个应用程序(MyApplication)，和一个类库（MyLibrary) ，MyApplication是引用了MyLibrary的。</p> <p><a href="http://images.cnitblog.com/blog/9072/201303/14171001-365ac314231a4d00af9b158dd3965b34.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171002-cb9bf4c46c4e48aabe493b0c9ed19c9a.png" width="244" height="134"></a></p> <p>MyLibrary中有一个TestClass类型，提供了一个简单的方法（SayHello）</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;
<span class="kwrd">using</span> System.Threading.Tasks;

<span class="kwrd">namespace</span> MyLibrary
{
    <span class="kwrd">public</span> <span class="kwrd">class</span> TestClass
    {
        <span class="kwrd">public</span> <span class="kwrd">void</span> SayHello()
        {
            <span class="rem">//这里为了演示方便，显示出来当前加载的程序集完整路径</span>
            Console.WriteLine(<span class="kwrd">this</span>.GetType().Assembly.Location);
            Console.WriteLine(<span class="str">"Hello,world"</span>);
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>&nbsp;</p>
<p>在MyApplication中，我们就是简单地创建了这个类型的实例，然后调用方法。</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;
<span class="kwrd">using</span> System.Threading.Tasks;

<span class="kwrd">namespace</span> MyApplication
{
    <span class="kwrd">class</span> Program
    {
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {
            var c = <span class="kwrd">new</span> MyLibrary.TestClass();
            c.SayHello();

            Console.Read();
        }
    }
}
</pre>
<p>默认情况下，如果我们编译整个项目，那么MyLibrary.dll会被自动地复制到MyApplication的根目录，如下图所示</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171003-6c80af4e33b2402d9a61e7268c79286c.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171003-94dfdb02d0394169b10263ba0791ecc9.png" width="244" height="168"></a></p>
<p>运行MyApplication.exe，我们能看到下面这样的输出</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171004-66bdbc72af0f44428365a96c679ba9a2.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171004-690a45ac8fc44550b99323a1e482bb7c.png" width="847" height="148"></a></p>
<p>我们可以很清楚地看到，当前加载的MyLibrary.dll是来自于MyApplication的根目录的。</p>
<p>&nbsp;</p>
<h1>2. 假如我们不想将MyLibrary.dll放在应用程序的根目录</h1>
<p>有时候，我们会希望单独存放MyLibrary.dll，那么第一种做法就是，直接在应用程序根目录下面建立一个与程序集同名的子目录，然后将程序集放进去。</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171004-3c9c1cabee6142f48f139e3c8f373ba6.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171005-1617bf55daf642b3a54afc840c80487c.png" width="515" height="128"></a></p>
<p>我们注意到，根目录下面的MyLibrary.dll 被移动到了MyLibrary目录<br><a href="http://images.cnitblog.com/blog/9072/201303/14171005-01b86f9794ef484ab037acb038542510.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171005-9541ead4e78f4a4e96f324514dff6aac.png" width="515" height="162"></a></p>
<p>然后，我们再次运行MyApplication.exe，能看到下面这样的输出：</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171007-50d3422c0d4b4963ae662562c3fd23c3.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171007-9538c0858882411c9990f0f7323f9286.png" width="903" height="130"></a></p>
<p>&nbsp;</p>
<h1>3.假如我们有很多程序集，希望统一放在一个目录</h1>
<p>第二步的方法虽然不错，但有一个问题，就是如果我们引用的程序集很多的话，就需要在根目录下面建立很多子目录。那么，有没有办法统一地将这些程序集放在一个目录中呢？</p>
<p>我们可以通过如下的方式，定义一个特殊的私有路径（PrivatePath）</p><pre class="csharpcode"><span class="kwrd">&lt;?</span><span class="html">xml</span> <span class="attr">version</span><span class="kwrd">="1.0"</span> <span class="attr">encoding</span><span class="kwrd">="utf-8"</span> ?<span class="kwrd">&gt;</span>
<span class="kwrd">&lt;</span><span class="html">configuration</span><span class="kwrd">&gt;</span>
  <span class="kwrd">&lt;</span><span class="html">runtime</span><span class="kwrd">&gt;</span>
    <span class="kwrd">&lt;</span><span class="html">assemblyBinding</span> <span class="attr">xmlns</span><span class="kwrd">="urn:schemas-microsoft-com:asm.v1"</span><span class="kwrd">&gt;</span>
      <span class="kwrd">&lt;</span><span class="html">probing</span> <span class="attr">privatePath</span><span class="kwrd">="libs"</span><span class="kwrd">&gt;&lt;/</span><span class="html">probing</span><span class="kwrd">&gt;</span>
    <span class="kwrd">&lt;/</span><span class="html">assemblyBinding</span><span class="kwrd">&gt;</span>
  <span class="kwrd">&lt;/</span><span class="html">runtime</span><span class="kwrd">&gt;</span>
<span class="kwrd">&lt;/</span><span class="html">configuration</span><span class="kwrd">&gt;</span></pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>同时，我们将MyLibrary.dll 移动到libs这个子目录下面去</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171008-946b1be492e742beadff6f8a76861eac.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171008-24fa9728434146f2bce46d10b6794dec.png" width="515" height="170"></a></p>
<p>然后，我们再次运行MyApplication.exe，能看到下面这样的输出：</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171009-00d3eaca0bf84d58a967401038b5f27f.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171009-c2b3303e859e43418414846e775427bf.png" width="806" height="153"></a></p>
<p>&nbsp;</p>
<p>这也就是说，对于没有签名的程序集，CLR一般会按照如下的规则查找和加载程序集</p>
<ol>
<li>程序的根目录</li>
<li>根目录下面，与被引用程序集同名的子目录</li>
<li>根目录下面被明确定义为私有目录的子目录</li><!--EndFragment--></ol>
<p>但是，有一个例外</p>
<h1>4. codebase的设置是优先的，而且是排他的</h1>
<p>codebase是一个特殊的设置，我们可以在配置文件中明确地指定某个程序集的查找路径，这个规则具有最高的优先级，而且如果你做了设置，CLR就一定会按照你的设置去查找，如果找不到，它就报告失败，而不会继续查找其他路径。</p><pre class="csharpcode"><span class="kwrd">&lt;?</span><span class="html">xml</span> <span class="attr">version</span><span class="kwrd">="1.0"</span> <span class="attr">encoding</span><span class="kwrd">="utf-8"</span> ?<span class="kwrd">&gt;</span>
<span class="kwrd">&lt;</span><span class="html">configuration</span><span class="kwrd">&gt;</span>
  <span class="kwrd">&lt;</span><span class="html">runtime</span><span class="kwrd">&gt;</span>
    <span class="kwrd">&lt;</span><span class="html">assemblyBinding</span> <span class="attr">xmlns</span><span class="kwrd">="urn:schemas-microsoft-com:asm.v1"</span><span class="kwrd">&gt;</span>
      <span class="kwrd">&lt;</span><span class="html">probing</span> <span class="attr">privatePath</span><span class="kwrd">="libs"</span><span class="kwrd">/&gt;</span>

      <span class="kwrd">&lt;</span><span class="html">dependentAssembly</span><span class="kwrd">&gt;</span>
        <span class="kwrd">&lt;</span><span class="html">assemblyIdentity</span> <span class="attr">name</span><span class="kwrd">="MyLibrary"</span>
                          <span class="attr">culture</span><span class="kwrd">="neutral"</span> <span class="kwrd">/&gt;</span>
        <span class="kwrd">&lt;</span><span class="html">codeBase</span> <span class="attr">version</span><span class="kwrd">="1.0.0.0"</span>
                  <span class="attr">href</span><span class="kwrd">="CodeBase\MyLibrary.dll"</span> <span class="kwrd">/&gt;</span>
      <span class="kwrd">&lt;/</span><span class="html">dependentAssembly</span><span class="kwrd">&gt;</span>
    <span class="kwrd">&lt;/</span><span class="html">assemblyBinding</span><span class="kwrd">&gt;</span>
  <span class="kwrd">&lt;/</span><span class="html">runtime</span><span class="kwrd">&gt;</span>
<span class="kwrd">&lt;/</span><span class="html">configuration</span><span class="kwrd">&gt;</span></pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>&nbsp;</p>







<p><a href="http://images.cnitblog.com/blog/9072/201303/14171009-1e864fa5c8d74d05bf0fef1e2c291b91.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171010-ee092531dd1844499973ee7ad57316fd.png" width="515" height="406"></a></p>
<p>&nbsp;</p>
<p>请注意，我们保留了libs目录和Mylibrary目录，而且根目录下面也保留了一个MyLibrary.dll。 实际上，当前我们一共有4个dll. 那么到底会加载哪一个呢？</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171010-1599103e3ec34012b3cce89959d0b97c.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171010-397d6c2f36f144f3a31b9c0461cac467.png" width="896" height="147"></a></p>
<p>这种情况下，如果codebase下面找不到MyLibrary.dll 会怎么样呢？</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171011-8acc96744bf144fbac7c600aac13d2d0.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171011-a342a8fa1f894554aff1b562c83b1839.png" width="1041" height="185"></a></p>
<p>我们发现他是会报告错误的，而不会查找其他目录的程序集。</p>
<p>&nbsp;</p>
<h1>5.如果有强名称签名会怎么样呢？</h1>
<p>对程序集进行强名称签名的好处是，可以将其添加到全局全局程序集缓存中。这样既可以实现程序集的共享，又可以从一定程度上提高性能。</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171011-93cb52f509ff43cd8f7492abee1c484e.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171012-d1f00d89ff7a4e86bf1e2029e5a82f2c.png" width="710" height="231"></a></p>
<p>签名后，我们将其添加到全局程序集缓存中去</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171013-0bb02fd9a0b8409698fa23effaef8e41.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171013-739780ab622744f0ae4294776cf1cf15.png" width="928" height="240"></a></p>
<p>那么这种情况下，不管我们在应用程序根目录（或者下面的子目录）有没有MyLibrary.dll ，CLR都是尝试先从全局程序集缓存中查找和加载的。</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171014-2e03460127e443dda6034b9a167805fb.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171014-bb17a1dc58814d36b04ed94a1599bd1b.png" width="1047" height="152"></a></p>






<p>&nbsp;</p>
<p>需要注意的是，如果程序集是经过了强名称签名，则在定义codebase的时候，应该注明publicKeyToken</p><pre class="csharpcode"><span class="kwrd">&lt;?</span><span class="html">xml</span> <span class="attr">version</span><span class="kwrd">="1.0"</span> <span class="attr">encoding</span><span class="kwrd">="utf-8"</span> ?<span class="kwrd">&gt;</span>
<span class="kwrd">&lt;</span><span class="html">configuration</span><span class="kwrd">&gt;</span>
  <span class="kwrd">&lt;</span><span class="html">runtime</span><span class="kwrd">&gt;</span>
    <span class="kwrd">&lt;</span><span class="html">assemblyBinding</span> <span class="attr">xmlns</span><span class="kwrd">="urn:schemas-microsoft-com:asm.v1"</span><span class="kwrd">&gt;</span>
      <span class="kwrd">&lt;</span><span class="html">probing</span> <span class="attr">privatePath</span><span class="kwrd">="libs"</span><span class="kwrd">/&gt;</span>

      <span class="kwrd">&lt;</span><span class="html">dependentAssembly</span><span class="kwrd">&gt;</span>
        <span class="kwrd">&lt;</span><span class="html">assemblyIdentity</span> <span class="attr">name</span><span class="kwrd">="MyLibrary"</span>
                          <span class="attr">publicKeyToken</span><span class="kwrd">="4a77fca346941a6c"</span>
                          <span class="attr">culture</span><span class="kwrd">="neutral"</span> <span class="kwrd">/&gt;</span>
        <span class="kwrd">&lt;</span><span class="html">codeBase</span> <span class="attr">version</span><span class="kwrd">="1.0.0.0"</span>
                  <span class="attr">href</span><span class="kwrd">="CodeBase\MyLibrary.dll"</span> <span class="kwrd">/&gt;</span>
      <span class="kwrd">&lt;/</span><span class="html">dependentAssembly</span><span class="kwrd">&gt;</span>
    <span class="kwrd">&lt;/</span><span class="html">assemblyBinding</span><span class="kwrd">&gt;</span>
  <span class="kwrd">&lt;/</span><span class="html">runtime</span><span class="kwrd">&gt;</span>
<span class="kwrd">&lt;/</span><span class="html">configuration</span><span class="kwrd">&gt;</span></pre><pre class="csharpcode"><span class="kwrd"></span>&nbsp;</pre><pre class="csharpcode"><span class="kwrd"></span>&nbsp;</pre><pre class="csharpcode"><span class="kwrd"></span>&nbsp;</pre>
<h1><span class="kwrd">总结</span></h1>
<p>本文通过实例讲解了CLR在查找和加载程序集的时候所遵循的一些规则，针对有强名称和没有强名称的程序集，这些规则略有不同。本文范例代码可以通过这里下载 <a title="http://files.cnblogs.com/chenxizhang/AssemblyMatchDemoSolution.zip" href="http://files.cnblogs.com/chenxizhang/AssemblyMatchDemoSolution.zip">http://files.cnblogs.com/chenxizhang/AssemblyMatchDemoSolution.zip</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1>相关问题</h1>
<p>本文还没有涵盖到的另外两个特殊情况，在日常工作中不多见，大家有兴趣可以再找些资料研读。</p>
<p>1.在目录中查找的时候，如果dll查找不到，则会尝试查找同名的exe</p>
<p>2.如果程序集带有区域性，而不是语言中立的，则还会尝试查找以语言区域命名的子目录。</p>
<p>通常情况下，我们都就是程序集设置为语言中立的，所以不存在这个问题</p>
<p><a href="http://images.cnitblog.com/blog/9072/201303/14171014-2e1ae3cbf3244c429e1d0faef1bb4f0d.png"><img title="image" border="0" alt="image" src="http://images.cnitblog.com/blog/9072/201303/14171015-b05ddd9be4f44f47b1bd2bc9b7be868c.png" width="434" height="463"></a></p>
<p>&nbsp;</p><pre class="csharpcode"><span class="kwrd"></span>&nbsp;</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>