# 多个异步任务串行化的思考和研究(Silverlight, AJAX场景) 
> 原文发表于 2012-09-18, 地址: http://www.cnblogs.com/chenxizhang/archive/2012/09/18/2690469.html 


<h1>内容摘要</h1> <p>异步编程在我们日常的开发工作中经常遇到的场景。现在的应用程序，很难说不需要进行异步的一些任务。例如网络服务的调用。典型的情况就在于Silverlight和AJAX场景中。</p> <p>一个异步任务的执行，可能很简单，.NET有大约4种所谓的异步编程模型，最常见的是基于回调的方式。每个异步任务，都是独立的一个线程，这些任务之间，默认情况下不会有依赖，也不会有先后顺序的概念的。他们一般是同时发出去的请求，然后根据具体每个任务的情况，会逐渐返回结果。但这里有一个情况就是，他们返回结果的时间是不可预期的。</p> <p>但是如果我们需要有多个异步任务，而且这些任务之间本身存在一定的先后次序，例如A先执行完，然后才能执行B，甚至A的结果要作为B的输入。那么这个时候应该怎么做呢？</p> <p>在.NET内部的实现中，可以通过在任务之间互相嵌套的方式简单地实现，但其代码向当地不易于阅读和扩展。</p> <p>为此，我们做了一些封装和改进。本次演讲，我首先讲解了默认的一些实现方式，然后着重演示了两种扩展</p> <p>1.使用AsyncTaskFactory 这个组件 <a href="http://nuget.org/packages/AsyncTaskFactory">http://nuget.org/packages/AsyncTaskFactory</a></p> <p>2.使用AsyncCTP这个组件：<a href="http://www.microsoft.com/en-us/download/details.aspx?id=9983">http://</a><a href="http://www.microsoft.com/en-us/download/details.aspx?id=9983">www.microsoft.com/en-us/download/details.aspx?id=9983</a></p> <p>本次演讲的最后，还讲解了如何在AJAX应用中使用队列的方式来实现多个异步任务的串行化。</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p> <h1>讲义地址</h1> <p><a title="http://sdrv.ms/Sw7ELi" href="http://sdrv.ms/Sw7ELi">http://sdrv.ms/Sw7ELi</a></p> <p>&nbsp;</p> <h1>视频地址</h1> <p><embed src="http://www.tudou.com/v/5CAiXEAjvGM/&amp;rpid=101037296&amp;resourceId=101037296_05_05_99&amp;bid=05/v.swf" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" wmode="opaque" width="480" height="400"></embed></p> <h1>演示代码：</h1> <p>完整源代码请通过这里下载：<a title="http://files.cnblogs.com/chenxizhang/AsyncQueueSample.zip" href="http://files.cnblogs.com/chenxizhang/AsyncQueueSample.zip">http://files.cnblogs.com/chenxizhang/AsyncQueueSample.zip</a> （需要Visual Studio 2010+Silvelight 4.0 Toolkit)</p> <p><font color="#ff0000">请结合视频理解代码</font></p> <p>&nbsp;</p><pre class="csharpcode"><span class="kwrd">服务代码</span></pre><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Web;
<span class="kwrd">using</span> System.Web.Services;
<span class="kwrd">using</span> System.Threading;

<span class="kwrd">namespace</span> AsyncQueueSample.Web
{
    <span class="rem">/// &lt;summary&gt;</span>
    <span class="rem">/// 这个例子用来演示多个异步任务的串行化，这里只是简单地模拟了一个长时间执行的方法，使用线程休眠</span>
    <span class="rem">/// 作者：陈希章</span>
    <span class="rem">/// 时间：2012年9月</span>
    <span class="rem">/// 反馈：ares@xizhang.com</span>
    <span class="rem">/// &lt;/summary&gt;</span>
    [WebService(Namespace = <span class="str">"http://tempuri.org/"</span>)]
    [WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
    [System.ComponentModel.ToolboxItem(<span class="kwrd">false</span>)]
    <span class="rem">// To allow this Web Service to be called from script, using ASP.NET AJAX, uncomment the following line. </span>
    [System.Web.Script.Services.ScriptService]
    <span class="kwrd">public</span> <span class="kwrd">class</span> SampleWebService : System.Web.Services.WebService
    {

        [WebMethod]
        <span class="kwrd">public</span> <span class="kwrd">string</span> HelloWorld()
        {

            Thread.Sleep(5000);
            <span class="kwrd">return</span> <span class="str">"Hello World"</span>;
        }


        [WebMethod]
        <span class="kwrd">public</span> <span class="kwrd">string</span> HelloWorld2()
        {

            Thread.Sleep(2000);
            <span class="kwrd">return</span> <span class="str">"Hello World 2"</span>;

        }

        [WebMethod]
        <span class="kwrd">public</span> <span class="kwrd">string</span> HelloWorld3()
        {

            Thread.Sleep(2000);
            <span class="kwrd">return</span> <span class="str">"Hello World 3"</span>;

        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
<pre class="csharpcode"><span class="kwrd"></span>&nbsp;</pre><pre class="csharpcode"><span class="kwrd"></span>&nbsp;</pre><pre class="csharpcode"><span class="kwrd">界面代码</span></pre><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.ServiceModel.DomainServices.Client;
<span class="kwrd">using</span> System.Threading.Tasks;
<span class="kwrd">using</span> System.Windows;
<span class="kwrd">using</span> System.Windows.Controls;

<span class="kwrd">namespace</span> AsyncQueueSample
{
    <span class="rem">/// &lt;summary&gt;</span>
    <span class="rem">/// 这个例子演示了如何实现多个异步任务的串行化</span>
    <span class="rem">/// 作者：陈希章</span>
    <span class="rem">/// 时间：2012年9月</span>
    <span class="rem">/// 反馈：ares@xizhang.com</span>
    <span class="rem">/// &lt;/summary&gt;</span>
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> MainPage : UserControl
    {
        <span class="kwrd">public</span> MainPage()
        {
            InitializeComponent();
        }


        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// 这是常规的并行方式，多个异步调用彼此是没有关联的，同时发出请求</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="sender"&gt;&lt;/param&gt;</span>
        <span class="rem">/// &lt;param name="e"&gt;&lt;/param&gt;</span>
        <span class="kwrd">private</span> <span class="kwrd">void</span> btASync_Click(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {
            var proxy = <span class="kwrd">new</span> localhost.SampleWebServiceSoapClient();
            proxy.HelloWorldCompleted += (o, a) =&gt; { MessageBox.Show(a.Result); };
            proxy.HelloWorldAsync();<span class="rem">//发出异步请求</span>

            proxy.HelloWorld2Completed += (o, a) =&gt; { MessageBox.Show(a.Result); };
            proxy.HelloWorld2Async();


        }
        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// 这是常规实现的串行方式，在任务之间手工实现顺序，耦合性很高</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="sender"&gt;&lt;/param&gt;</span>
        <span class="rem">/// &lt;param name="e"&gt;&lt;/param&gt;</span>
        <span class="kwrd">private</span> <span class="kwrd">void</span> btNormal_Click(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {
            var proxy = <span class="kwrd">new</span> localhost.SampleWebServiceSoapClient();
            proxy.HelloWorldCompleted += (o, a) =&gt;<span class="rem">//第一个任务的回调</span>
            {
                MessageBox.Show(a.Result);

                proxy.HelloWorld2Completed += (o1, a1) =&gt;<span class="rem">//第二个任务的回调</span>
                {
                    MessageBox.Show(a1.Result);

                    proxy.HelloWorld3Completed += (o2, a2) =&gt;
                    {
                        MessageBox.Show(a2.Result);
                    };

                    proxy.HelloWorld3Async();

                };

                proxy.HelloWorld2Async();
            };

            proxy.HelloWorldAsync();
        }

        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// 使用AsyncTaskFactory改进的做法</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="sender"&gt;&lt;/param&gt;</span>
        <span class="rem">/// &lt;param name="e"&gt;&lt;/param&gt;</span>
        <span class="kwrd">private</span> <span class="kwrd">void</span> btAsyncTaskFactory_Click(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {
            var proxy = <span class="kwrd">new</span> localhost.SampleWebServiceSoapClient();
            var task1 = <span class="kwrd">new</span> AsyncAction(<span class="str">"task 1"</span>);
            task1.SetAction(() =&gt;
            {
                proxy.HelloWorldCompleted += (o, a) =&gt; { MessageBox.Show(a.Result); task1.OnCompleted(); };
                proxy.HelloWorldAsync();
            });

            var task2 = <span class="kwrd">new</span> AsyncAction(<span class="str">"task 2"</span>);
            task2.SetAction(() =&gt;
            {
                proxy.HelloWorld2Completed += (o, a) =&gt; { MessageBox.Show(a.Result); task2.OnCompleted(); };
                proxy.HelloWorld2Async();
            });


            var task3 = <span class="kwrd">new</span> AsyncAction(<span class="str">"task 3"</span>);
            task3.SetAction(() =&gt;
            {
                proxy.HelloWorld3Completed += (o, a) =&gt; { MessageBox.Show(a.Result); task3.OnCompleted(); };
                proxy.HelloWorld3Async();
            });


            var runner = <span class="kwrd">new</span> AsyncActionRunner(task1, task3, task2);
            runner.Execute();
        }

        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// 使用AsyncCTP改进的做法</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="sender"&gt;&lt;/param&gt;</span>
        <span class="rem">/// &lt;param name="e"&gt;&lt;/param&gt;</span>
        async <span class="kwrd">private</span> <span class="kwrd">void</span> btAsyncCTP_Click(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {
            var proxy = <span class="kwrd">new</span> localhost.SampleWebServiceSoapClient() <span class="kwrd">as</span> localhost.SampleWebServiceSoap;

            var result1 = await Task&lt;localhost.HelloWorldResponse&gt;.Factory.FromAsync(
                proxy.BeginHelloWorld(<span class="kwrd">new</span> localhost.HelloWorldRequest(), <span class="kwrd">null</span>, <span class="kwrd">null</span>),
                proxy.EndHelloWorld);

            MessageBox.Show(result1.Body.HelloWorldResult);

            var result3 = await Task&lt;localhost.HelloWorld3Response&gt;.Factory.FromAsync(
                proxy.BeginHelloWorld3(<span class="kwrd">new</span> localhost.HelloWorld3Request(), <span class="kwrd">null</span>, <span class="kwrd">null</span>),
                proxy.EndHelloWorld3);
            MessageBox.Show(result3.Body.HelloWorld3Result);

            var result2 = await Task&lt;localhost.HelloWorld2Response&gt;.Factory.FromAsync(
                proxy.BeginHelloWorld2(<span class="kwrd">new</span> localhost.HelloWorld2Request(), <span class="kwrd">null</span>, <span class="kwrd">null</span>),
                proxy.EndHelloWorld2);
            MessageBox.Show(result2.Body.HelloWorld2Result);

        }

        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// 标准的RIA Service调用的做法</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="sender"&gt;&lt;/param&gt;</span>
        <span class="rem">/// &lt;param name="e"&gt;&lt;/param&gt;</span>
        <span class="kwrd">private</span> <span class="kwrd">void</span> btRIAService_Click(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {
            var ctx = <span class="kwrd">new</span> Web.SampleDomainContext();
            ctx.Load&lt;Web.Employee&gt;(ctx.GetEmployeesQuery(), result =&gt;
            {
                MessageBox.Show(result.Entities.FirstOrDefault().FirstName);
            }, <span class="kwrd">true</span>);

            MessageBox.Show(<span class="str">"加载完成"</span>);
        }

        <span class="rem">/// &lt;summary&gt;</span>
        <span class="rem">/// 使用AsyncCTP改进的RIA Service调用的做法</span>
        <span class="rem">/// &lt;/summary&gt;</span>
        <span class="rem">/// &lt;param name="sender"&gt;&lt;/param&gt;</span>
        <span class="rem">/// &lt;param name="e"&gt;&lt;/param&gt;</span>
        async <span class="kwrd">private</span> <span class="kwrd">void</span> btAsyncCTPRIA_Click(<span class="kwrd">object</span> sender, RoutedEventArgs e)
        {
            var ctx = <span class="kwrd">new</span> Web.SampleDomainContext();
            var result = await ctx.Load&lt;Web.Employee&gt;(ctx.GetEmployeesQuery()).AsTask();
            MessageBox.Show(result.Entities.FirstOrDefault().FirstName);



            MessageBox.Show(<span class="str">"加载完成"</span>);
        }

    }

    <span class="rem">/// &lt;summary&gt;</span>
    <span class="rem">/// 对于RIA Service的一个扩展方法</span>
    <span class="rem">/// &lt;/summary&gt;</span>
    <span class="kwrd">public</span> <span class="kwrd">static</span> <span class="kwrd">class</span> OperationExtensions
    {
        <span class="kwrd">public</span> <span class="kwrd">static</span> Task&lt;T&gt; AsTask&lt;T&gt;(<span class="kwrd">this</span> T operation)
          <span class="kwrd">where</span> T : OperationBase
        {
            TaskCompletionSource&lt;T&gt; tcs =
              <span class="kwrd">new</span> TaskCompletionSource&lt;T&gt;(operation.UserState);

            operation.Completed += (sender, e) =&gt;
            {
                <span class="kwrd">if</span> (operation.HasError &amp;&amp; !operation.IsErrorHandled)
                {
                    tcs.TrySetException(operation.Error);
                    operation.MarkErrorAsHandled();
                }
                <span class="kwrd">else</span> <span class="kwrd">if</span> (operation.IsCanceled)
                {
                    tcs.TrySetCanceled();
                }
                <span class="kwrd">else</span>
                {
                    tcs.TrySetResult(operation);
                }
            };

            <span class="kwrd">return</span> tcs.Task;
        }
    }

}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>