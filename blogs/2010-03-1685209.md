# 支持取消操作和暂停操作的Backgroundworker 
> 原文发表于 2010-03-13, 地址: http://www.cnblogs.com/chenxizhang/archive/2010/03/13/1685209.html 


<p>这也是今天讨论的话题。取消是默认就支持的，而暂停则默认不支持。但通过ManualResetEvent可以对其进行干预。</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.ComponentModel;
<span class="kwrd">using</span> System.Data;
<span class="kwrd">using</span> System.Drawing;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;
<span class="kwrd">using</span> System.Windows.Forms;
<span class="kwrd">using</span> System.Threading;

<span class="kwrd">namespace</span> BackgroundWorkderPauseSample
{
    <span class="kwrd">public</span> <span class="kwrd">partial</span> <span class="kwrd">class</span> MainForm : Form
    {
        BackgroundWorker worker = <span class="kwrd">null</span>;

        <span class="kwrd">public</span> MainForm()
        {
            InitializeComponent();
            Load += <span class="kwrd">new</span> EventHandler(Form1_Load);
        }

        <span class="kwrd">void</span> Form1_Load(<span class="kwrd">object</span> sender, EventArgs e)
        {
            worker = <span class="kwrd">new</span> BackgroundWorker();
            worker.WorkerReportsProgress = <span class="kwrd">true</span>;
            worker.WorkerSupportsCancellation = <span class="kwrd">true</span>;
            worker.DoWork += <span class="kwrd">new</span> DoWorkEventHandler(worker_DoWork);
            worker.RunWorkerCompleted += <span class="kwrd">new</span> RunWorkerCompletedEventHandler(worker_RunWorkerCompleted);
            worker.ProgressChanged += <span class="kwrd">new</span> ProgressChangedEventHandler(worker_ProgressChanged);
            
        }

        <span class="kwrd">void</span> worker_ProgressChanged(<span class="kwrd">object</span> sender, ProgressChangedEventArgs e)
        {
            progressBar1.Value = e.ProgressPercentage;
        }

        <span class="kwrd">void</span> worker_RunWorkerCompleted(<span class="kwrd">object</span> sender, RunWorkerCompletedEventArgs e)
        {
            <span class="kwrd">if</span> (e.Cancelled)
                MessageBox.Show(<span class="str">"用户取消了操作"</span>);
            <span class="kwrd">else</span>
            {
                MessageBox.Show(<span class="str">"正常完成了操作"</span>);
            }

        }

        <span class="kwrd">void</span> worker_DoWork(<span class="kwrd">object</span> sender, DoWorkEventArgs e)
        {
            <span class="kwrd">for</span> (<span class="kwrd">int</span> i = 0; i &lt; 100; i++)
            {
                <span class="kwrd">if</span> (worker.CancellationPending)<span class="rem">//如果用户申请取消</span>
                {
                    <span class="kwrd">for</span> (<span class="kwrd">int</span> k = i; k &gt;= 0; k--)
                    {
                        Thread.Sleep(10);
                        worker.ReportProgress(k);<span class="rem">//模拟一个回滚的效果</span>
                    }
                    e.Cancel = <span class="kwrd">true</span>;
                    <span class="kwrd">return</span>;
                }

                manualReset.WaitOne();<span class="rem">//如果ManualResetEvent的初始化为终止状态（true），那么该方法将一直工作，直到收到Reset信号。然后，直到收到Set信号，就继续工作。</span>
                <span class="rem">//反之亦然</span>
                Thread.Sleep(500);
                worker.ReportProgress(i+1);

            }
        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> btStart_Click(<span class="kwrd">object</span> sender, EventArgs e)
        {
            worker.RunWorkerAsync();
        }

        <span class="kwrd">private</span> <span class="kwrd">void</span> btCancel_Click(<span class="kwrd">object</span> sender, EventArgs e)
        {
            worker.CancelAsync();
        }


        <span class="kwrd">private</span> ManualResetEvent manualReset = <span class="kwrd">new</span> ManualResetEvent(<span class="kwrd">true</span>);

        <span class="kwrd">private</span> <span class="kwrd">void</span> btPause_Click(<span class="kwrd">object</span> sender, EventArgs e)
        {
            <span class="kwrd">if</span> (btPause.Text == <span class="str">"暂停"</span>)
            {
                manualReset.Reset();<span class="rem">//暂停当前线程的工作，发信号给waitOne方法，阻塞</span>
                btPause.Text = <span class="str">"继续"</span>;
            }
            <span class="kwrd">else</span>
            {
                manualReset.Set();<span class="rem">//继续某个线程的工作</span>
                btPause.Text = <span class="str">"暂停"</span>;
            }
        }
    }
}
这个程序运行的效果大致如下</pre><pre class="csharpcode">一。正常状态</pre><pre class="csharpcode"><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/Backgroundworker_1160D/image_2.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/Backgroundworker_1160D/image_thumb.png" width="566" height="238"></a> </pre><pre class="csharpcode">二。暂停状态</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/Backgroundworker_1160D/image_4.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/Backgroundworker_1160D/image_thumb_1.png" width="566" height="238"></a> </p>
<p>三。恢复状态</p>
<p><a href="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/Backgroundworker_1160D/image_6.png" class="thickbox"><img title="image" border="0" alt="image" src="http://images.cnblogs.com/cnblogs_com/chenxizhang/WindowsLiveWriter/Backgroundworker_1160D/image_thumb_2.png" width="566" height="238"></a> </p>
<p></p>
<p>作为演示，代码比较简单，没有对worker的一些状态进行判断以及按钮相应的设置。仅供参考</p>