# 如何通過編程獲取列表項目的附件以及多行文本中的文件內容 
> 原文发表于 2011-04-23, 地址: http://www.cnblogs.com/chenxizhang/archive/2011/04/23/2025564.html 


<p>我們都知道在SharePoint的列表中，可以有多種方式附加文件。例如下圖所示，在一個列表項目上，我們添加了多行文本字段，在該字段中，添加了兩個文件，並且我們在整個列表項目上，也添加了兩個附件。</p> <p>那麼對於這些文件的編程訪問，是否有比較標準和簡單的方法呢？今天我就整理一下給大家參考參考</p> <p><a href="http://www.xizhang.com/blogimages/44fd06a5d978_9CB1/image.png"><img title="image" border="0" alt="image" src="http://www.xizhang.com/blogimages/44fd06a5d978_9CB1/image_thumb.png" width="656" height="468"></a></p> <p>&nbsp;</p> <p>那麼，首先來看一下，如何獲取多行文本中的附件內容呢？</p> <p>我們可以先看一下，多行文本裡面的內容是怎麼樣的</p> <p><a href="http://www.xizhang.com/blogimages/44fd06a5d978_9CB1/image_3.png"><img title="image" border="0" alt="image" src="http://www.xizhang.com/blogimages/44fd06a5d978_9CB1/image_thumb_3.png" width="992" height="346"></a></p> <p>很顯然，這個字段的值一般都是一個DIV，說白了其實是一段HTML的內容</p> <p>那麼，這樣也就好辦了，通過如下代碼可以很容易獲得文件和文件內容</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;
<span class="kwrd">using</span> System.Xml.Linq;
<span class="kwrd">using</span> Microsoft.SharePoint;

<span class="kwrd">namespace</span> ConsoleApplication1
{
    <span class="kwrd">class</span> Program
    {
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {

            <span class="kwrd">using</span> (var site = <span class="kwrd">new</span> SPSite(<span class="str">@"http://chenxizhang-pc"</span>))
            {
                <span class="kwrd">using</span> (var web = site.OpenWeb())
                {
                    var list = web.Lists[<span class="str">"TestList"</span>];
                    var items = list.GetItems();

                    <span class="kwrd">foreach</span> (SPListItem item <span class="kwrd">in</span> items)<span class="rem">//遍歷所有的Item</span>
                    {

                        var content = item[<span class="str">"Test"</span>].ToString();<span class="rem">//獲得多行文本字段的值</span>
                        var element = XElement.Parse(content);<span class="rem">//轉換為一個XElement，以便進一步的操作</span>

                        var links = element.Descendants(<span class="str">"a"</span>);<span class="rem">//獲得內部所有的鏈接</span>
                        <span class="kwrd">foreach</span> (var link <span class="kwrd">in</span> links)
                        {
                            var fileName = link.Value;<span class="rem">//獲得鏈接的文本</span>
                            var fileUrl = link.Attribute(<span class="str">"href"</span>).Value;<span class="rem">//獲取鏈接的地址</span>
                            Console.WriteLine(<span class="str">"{0} :{1}"</span>, fileName, fileUrl);
                            var file = web.GetFile(fileUrl);<span class="rem">//獲取文件的引用</span>
                            var bytes = file.OpenBinary();<span class="rem">//獲取文件的內容</span>

                            var result = Encoding.UTF8.GetString(bytes);<span class="rem">//轉換為字符串，我測試的文件是文本文件，所以可以這樣直接轉換</span>
                            Console.WriteLine(result);
                        }
                    }
                }
            }
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>

<p>&nbsp;</p>
<p>接下來看一下如何獲取列表項目的附件（注意，這是直接附加到ListItem上面的），這個操作相對更加簡單一些，每個Item都有一個Attachments的屬性集合。</p><pre class="csharpcode"><span class="kwrd">using</span> System;
<span class="kwrd">using</span> System.Collections.Generic;
<span class="kwrd">using</span> System.Linq;
<span class="kwrd">using</span> System.Text;

<span class="kwrd">using</span> Microsoft.SharePoint;

<span class="kwrd">namespace</span> ConsoleApplication1
{
    <span class="kwrd">class</span> Program
    {
        <span class="kwrd">static</span> <span class="kwrd">void</span> Main(<span class="kwrd">string</span>[] args)
        {

            <span class="kwrd">using</span> (var site = <span class="kwrd">new</span> SPSite(<span class="str">@"http://chenxizhang-pc"</span>))
            {
                <span class="kwrd">using</span> (var web = site.OpenWeb())
                {
                    var list = web.Lists[<span class="str">"TestList"</span>];
                    var items = list.GetItems();

                    <span class="kwrd">foreach</span> (SPListItem item <span class="kwrd">in</span> items)<span class="rem">//遍歷所有的Item</span>
                    {
                        <span class="kwrd">foreach</span> (var att <span class="kwrd">in</span> item.Attachments)<span class="rem">//遍歷所有的Attachment</span>
                        {
                            var url=<span class="kwrd">string</span>.Format(<span class="str">"{0}{1}"</span>,item.Attachments.UrlPrefix,att);<span class="rem">//獲得文件路徑</span>
                            var file = web.GetFile(url);<span class="rem">//獲取文件引用</span>
                            var bytes = file.OpenBinary();<span class="rem">//取得文件內容</span>
                            var content = Encoding.UTF8.GetString(bytes);<span class="rem">//轉換為字符串，我的這個文件是文本文件，所以可以直接這樣轉</span>
                            Console.WriteLine(content);
                        }
                        
                    }
                }
            }
        }
    }
}
</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>