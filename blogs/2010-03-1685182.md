# 关于Thread.IsAlive属性 
> 原文发表于 2010-03-13, 地址: http://www.cnblogs.com/chenxizhang/archive/2010/03/13/1685182.html 


<p>今天在讨论多线程的时候，谈到了这个属性。IsAlive，顾名思义，它表示线程当前是否为可用状态，如果线程已经启动，并且当前没有任何异常的话，则返回true，否则为false</p> <p>为什么要了解这个属性，是因为下面代码有的朋友不是很理解</p> <p>下面代码演示的多个线程对共享资源争用的问题，具体细节这里不详细讨论了。</p><pre class="csharpcode">            Thread thread1 = <span class="kwrd">new</span> Thread(<span class="kwrd">new</span> ThreadStart(SomeMethod));
            Thread thread2 = <span class="kwrd">new</span> Thread(<span class="kwrd">new</span> ThreadStart(SomeMethod));
            Thread thread3 = <span class="kwrd">new</span> Thread(<span class="kwrd">new</span> ThreadStart(SomeMethod));
            Thread thread4 = <span class="kwrd">new</span> Thread(<span class="kwrd">new</span> ThreadStart(SomeMethod));
            Thread thread5 = <span class="kwrd">new</span> Thread(<span class="kwrd">new</span> ThreadStart(SomeMethod));

            thread1.Name = <span class="str">"Thread 1"</span>;
            thread2.Name = <span class="str">"Thread 2"</span>;
            thread3.Name = <span class="str">"Thread 3"</span>;
            thread4.Name = <span class="str">"Thread 4"</span>;
            thread5.Name = <span class="str">"Thread 5"</span>;
            thread1.Start();

            <span class="kwrd">while</span> (!thread1.IsAlive)
                Thread.Sleep(100);

            thread2.Start();
            <span class="kwrd">while</span> (!thread2.IsAlive)
                Thread.Sleep(100);

            thread3.Start();
            <span class="kwrd">while</span> (!thread3.IsAlive)
                Thread.Sleep(100);

            thread4.Start();
            <span class="kwrd">while</span> (!thread4.IsAlive)
                Thread.Sleep(100);

            thread5.Start();
            <span class="kwrd">while</span> (!thread5.IsAlive)
                Thread.Sleep(100);</pre><pre class="csharpcode">&nbsp;</pre><pre class="csharpcode">大家有些疑惑的是，为什么Thread.Start之后，要用while去等待它Alive呢？这个代码通常不写的话，也是没有什么问题的。</pre><pre class="csharpcode">但原理上说，其实简单地Start，并不代表线程能马上启动起来（也许CPU正在忙其他的事情），当然它迟早会被启动起来，但上面的代码<strong><font size="4">确保了几个线程是依次被启动的</font></strong>。</pre><pre class="csharpcode">&nbsp;</pre><pre class="csharpcode">&nbsp;</pre>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>