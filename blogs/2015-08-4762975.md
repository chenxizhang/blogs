# Rust初步（七）：格式化 
> 原文发表于 2015-08-27, 地址: http://www.cnblogs.com/chenxizhang/p/4762975.html 


<p>在Rust中，如果要进行屏幕输出，或者写入到文件中，需要对数据进行格式化。这一篇总结一下它所支持的几种格式化方式。</p> <p>这篇文章参考了以下官方文档，不过，按照我的风格，我还是会突出于C#语言的比较，这样可能更好懂一些。</p> <p><a title="http://rustbyexample.com/hello/print.html" href="http://rustbyexample.com/hello/print.html">http://rustbyexample.com/hello/print.html</a></p> <p><a title="http://doc.rust-lang.org/std/fmt/" href="http://doc.rust-lang.org/std/fmt/">http://doc.rust-lang.org/std/fmt/</a></p> <p><a title="http://rustbyexample.com/hello/print/print_debug.html" href="http://rustbyexample.com/hello/print/print_debug.html">http://rustbyexample.com/hello/print/print_debug.html</a></p> <p><a title="http://rustbyexample.com/hello/print/print_display.html" href="http://rustbyexample.com/hello/print/print_display.html">http://rustbyexample.com/hello/print/print_display.html</a></p> <p>&nbsp;</p> <p>首先，有三个常见的宏，可以用来做格式化</p> <ul> <li><strong><font color="#ff0000"><code>format!</code>:</font></strong> write formatted text to <a href="http://rustbyexample.com/std/str.html"><code>String</code></a>&nbsp; 这个宏可以将一个文本格式化成String类型（可变字符串，在堆上面分配空间），类似于C#中的String.Format方法。 <li><code><strong><font color="#ff0000">print!</font></strong></code>: same as <code>format!</code> but the text is printed to the console.&nbsp; 和format！这个宏功能一样，只不过是输出到屏幕上。类似于C#中的Console.Write方法。 <li><font color="#ff0000"><code>println!</code>:</font> same as <code>print!</code> but a newline is appended. 同上，只不过添加了换行符，类似于C#中的Console.WriteLine方法。</li></ul> <p>&nbsp;</p> <p>既然搞清楚了这三个宏，与C#中有关实现方式的关系，其实就很好理解了。一般这类方法，都可以比较方便地组合字符串，通过占位符这种东西。在C#中，用{0}表示第一个占位符，用{1}表示第二个占位符，依次类推。</p> <p><a title="https://msdn.microsoft.com/zh-cn/library/system.string.format(v=vs.110).aspx" href="https://msdn.microsoft.com/zh-cn/library/system.string.format(v=vs.110).aspx">https://msdn.microsoft.com/zh-cn/library/system.string.format(v=vs.110).aspx</a></p> <p><a title="https://msdn.microsoft.com/zh-cn/library/txafckwd(v=vs.110).aspx" href="https://msdn.microsoft.com/zh-cn/library/txafckwd(v=vs.110).aspx">https://msdn.microsoft.com/zh-cn/library/txafckwd(v=vs.110).aspx</a></p> <p>但是Rust提供了一些自己的创新做法,它可以直接用空的占位符 {}（这个在C#中不允许的），也可以用带序号的占位符 {0}，还直接带名称的占位符{name}，同样，也支持在占位符里面指定特殊格式化的符号，例如{:?} 。 这里有一篇详细的介绍<a title="http://doc.rust-lang.org/std/fmt/" href="http://doc.rust-lang.org/std/fmt/">http://doc.rust-lang.org/std/fmt/</a>&nbsp;</p><pre class="csharpcode">fn main() {
    <span class="rem">// In general, the `{}` will be automatically replaced with any</span>
    <span class="rem">// arguments. These will be stringified.</span>
    println!(<span class="str">"{} days"</span>, 31);

    <span class="rem">// Without a suffix, 31 becomes an i32. You can change what type 31 is,</span>
    <span class="rem">// with a suffix.</span>

    <span class="rem">// There are various optional patterns this works with. Positional</span>
    <span class="rem">// arguments can be used.</span>
    println!(<span class="str">"{0}, this is {1}. {1}, this is {0}"</span>, <span class="str">"Alice"</span>, <span class="str">"Bob"</span>);

    <span class="rem">// As can named arguments.</span>
    println!(<span class="str">"{subject} {verb} {predicate}"</span>,
             predicate=<span class="str">"over the lazy dog"</span>,
             subject=<span class="str">"the quick brown fox"</span>,
             verb=<span class="str">"jumps"</span>);

    <span class="rem">// Special formatting can be specified after a `:`.</span>
    println!(<span class="str">"{} of {:b} people know binary, the other half don't"</span>, 1, 2);

    <span class="rem">// It will even check to make sure the correct number of arguments are</span>
    <span class="rem">// used.</span>
    println!(<span class="str">"My name is {0}, {1} {0}"</span>, <span class="str">"Bond"</span>);
    <span class="rem">// FIXME ^ Add the missing argument: "James"</span>

    <span class="rem">// Create a structure which contains an `i32`. Name it `Structure`.</span>
    <span class="kwrd">struct</span> Structure(i32);

    <span class="rem">// However, custom types such as this structure require more complicated</span>
    <span class="rem">// handling. This will not work.</span>
    println!(<span class="str">"This struct `{}` won't print..."</span>, Structure(3));
    <span class="rem">// FIXME ^ Comment out this line.</span>
}</pre>
<p>知道了如何做格式化，下面要讨论一个问题：具体对象到底怎么实现自己的字符串表现形式的呢？其实，之前我已经略微介绍到了这个问题 </p>
<h4><a href="http://www.cnblogs.com/chenxizhang/p/4760087.html">Rust初步（四）：在rust中处理时间</a></h4>
<p>&nbsp;</p>
<p>从上面的例子中，我们知道，要将一个对象作为一个字符串输出的话，就需要对其进行转换。我们在C#中就是要实现ToString方法，在Rust里面，分别有两个方法Debug和Display方法。如果是元类型（Primitive Type），当然是没有问题的，基本上都已经实现了。</p>
<ul>
<li><code>fmt::Debug</code>: Uses the <code>{:?}</code> marker. Format text for debugging purposes.&nbsp; 如果我们的占位符使用{:?}，默认会调用对象的Debug方法，如果没有，则会报告错误
<li><code>fmt::Display</code>: Uses the <code>{}</code> marker. Format text in a more elegant, user friendly fashion.如果我们的占位符使用{},，默认会调用对象的Display方法，如果没有，则会报告错误</li></ul>
<p>注意，除了这两种形式，还有其他一些格式化输出方式</p>
<ul>
<li><em>unspecified</em> -&gt; <code>Display</code>
<li><code>?</code> -&gt; <code>Debug</code>
<li><code>o</code> –&gt; <code>Octal //8进制</code>
<li><code>x</code> –&gt; <code>LowerHex //16进制</code>
<li><code>X</code> -&gt; <code>UpperHex</code>
<li><code>p</code> –&gt; <code>Pointer </code>
<li><code>b</code> –&gt; <code>Binary //二进制</code>
<li><code>e</code> -&gt; <code>LowerExp</code>
<li><code>E</code> -&gt; <code>UpperExp</code></li></ul>
<p>下面考虑一个例子，来加深理解</p><pre class="csharpcode">
<span class="kwrd">struct</span> Point{ <span class="rem">//自定义一个结构体</span>
    x:i32,
    y:i32
}

fn main() {
    let p = Point{x:3,y:5};
    println!(<span class="str">"{}"</span>,p.x);<span class="rem">//打印x，这会成功</span>
    println!(<span class="str">"{:?}"</span>,p);<span class="rem">//直接打印整个结构体，因为没有实现Debug，会失败</span>
    println!(<span class="str">"{}"</span>,p);<span class="rem">//直接打印整个结构体，因为没有实现Display，会失败</span>
}
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p>这个例子连编译都不会通过</p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/271259428129313.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/271259435313700.png" width="630" height="143"></a></p>
<p>那么，如何实现Debug和Display呢？</p>
<p>Debug相对来说很简单，只要声明一下即可</p><pre class="csharpcode">#[derive(Debug)]
<span class="kwrd">struct</span> Point{ <span class="rem">//自定义一个结构体</span>
    x:i32,
    y:i32
}

fn main() {
    let p = Point{x:3,y:5};
    println!(<span class="str">"{}"</span>,p.x);<span class="rem">//打印x，这会成功</span>
    println!(<span class="str">"{:?}"</span>,p);<span class="rem">//直接打印整个结构体，因为已经实现Debug，会成功</span>
    
}
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
</p>
<p><font size="2" face="Consolas">那么，它是怎样输出的呢？</font></p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/271259439064514.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/271259444379843.png" width="619" height="88"></a></p>
<p>实际上就很类似于C#中所有Object的默认实现（ToString）</p>
<p>&nbsp;</p>
<p>相比而言，Display是需要手工来实现的，大致如下</p><pre class="csharpcode">use std::fmt;

#[derive(Debug)]
<span class="kwrd">struct</span> Point{ <span class="rem">//自定义一个结构体</span>
    x:i32,
    y:i32
}

impl fmt::Display <span class="kwrd">for</span> Point{
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
          write!(f, <span class="str">"x为{}，y为{}"</span>, self.x,self.y)
      }

}

fn main() {
    let p = Point{x:3,y:5};
    println!(<span class="str">"{}"</span>,p);<span class="rem">//直接打印整个结构体，因为已经实现Debug，会成功</span>

}
</pre>
<p>
<style type="text/css">.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	background-color: #ffffff;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }
</style>
输出结果如下</p>
<p><a href="http://images0.cnblogs.com/blog/9072/201508/271259447505171.png"><img title="image" border="0" alt="image" src="http://images0.cnblogs.com/blog/9072/201508/271259453759529.png" width="617" height="69"></a></p>